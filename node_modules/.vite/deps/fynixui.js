// node_modules/fynixui/dist/context/context.js
var activeContext = null;
function setActiveContext(ctx) {
  activeContext = ctx;
}

// node_modules/fynixui/dist/custom/button.js
function Button({ value = "", ...props }) {
  return Fynix("button", props, value);
}

// node_modules/fynixui/dist/custom/path.js
var propsCounter = 0;
function Path({ to = "#", value = "", props: routeProps = {}, ...attrs }) {
  const wrappedProps = {};
  for (const [k, v] of Object.entries(routeProps)) {
    wrappedProps[k] = v && v._isNixState ? v : nixState(v);
  }
  const propsKey = `fynixProp_${Date.now()}_${propsCounter++}`;
  if (!window.__fynixLinkProps__) {
    window.__fynixLinkProps__ = {};
  }
  window.__fynixLinkProps__[propsKey] = wrappedProps;
  const el = Fynix("a", {
    href: to,
    "data-fynix-link": true,
    "data-props-key": propsKey,
    ...attrs
  }, value);
  return el;
}

// node_modules/fynixui/dist/error/errorOverlay.js
function showErrorOverlay(error) {
  removeErrorOverlay();
  const overlay = document.createElement("div");
  overlay.id = "dev-error-overlay";
  Object.assign(overlay.style, {
    position: "fixed",
    inset: 0,
    width: "100%",
    height: "100%",
    backgroundColor: "rgba(0, 0, 0, 0.9)",
    color: "#fff",
    fontFamily: "Consolas, monospace",
    padding: "30px",
    zIndex: 99999,
    overflowY: "auto",
    transition: "opacity 0.25s ease",
    opacity: "0"
  });
  const container = document.createElement("div");
  container.style.position = "relative";
  container.style.maxWidth = "900px";
  container.style.margin = "50px auto";
  container.style.background = "rgba(255, 255, 255, 0.05)";
  container.style.borderRadius = "8px";
  container.style.padding = "20px 30px";
  container.style.boxShadow = "0 0 10px rgba(255, 0, 0, 0.3)";
  const closeBtn = document.createElement("button");
  closeBtn.textContent = "Ã— Close";
  Object.assign(closeBtn.style, {
    position: "absolute",
    top: "10px",
    right: "10px",
    background: "#ff5555",
    color: "#fff",
    border: "none",
    padding: "6px 12px",
    fontSize: "16px",
    borderRadius: "4px",
    cursor: "pointer",
    zIndex: 10
  });
  closeBtn.addEventListener("click", () => removeErrorOverlay());
  container.appendChild(closeBtn);
  const title = document.createElement("h1");
  title.textContent = "Runtime Error";
  Object.assign(title.style, {
    color: "#ff5555",
    fontSize: "24px",
    marginBottom: "10px"
  });
  const message = document.createElement("pre");
  message.textContent = error?.message || "Unknown error";
  Object.assign(message.style, {
    whiteSpace: "pre-wrap",
    background: "rgba(255, 255, 255, 0.1)",
    padding: "10px",
    borderRadius: "6px",
    marginTop: "10px",
    color: "#ffaaaa"
  });
  const stack = document.createElement("pre");
  stack.textContent = error?.stack || "";
  Object.assign(stack.style, {
    whiteSpace: "pre-wrap",
    marginTop: "15px",
    color: "#ccc"
  });
  container.appendChild(title);
  container.appendChild(message);
  container.appendChild(stack);
  overlay.appendChild(container);
  document.body.appendChild(overlay);
  requestAnimationFrame(() => {
    overlay.style.opacity = "1";
  });
  console.error("[FynixJS Runtime Error]", error);
}
function removeErrorOverlay() {
  const existing = document.getElementById("dev-error-overlay");
  if (existing) {
    existing.style.opacity = "0";
    setTimeout(() => existing.remove(), 200);
  }
}

// node_modules/fynixui/dist/hooks/nixState.js
function nixState(initial) {
  const ctx = activeContext;
  if (!ctx)
    throw new Error("nixState() called outside component");
  const idx = ctx.hookIndex++;
  if (!ctx.hooks[idx]) {
    let value = initial;
    const subscribers = /* @__PURE__ */ new Set();
    let isDestroyed = false;
    if (initial !== null && typeof initial === "object") {
      if ("__proto__" in initial || "constructor" in initial || "prototype" in initial) {
        if (Array.isArray(initial)) {
          value = [...initial];
        } else {
          value = { ...initial };
          delete value.__proto__;
          delete value.constructor;
          delete value.prototype;
        }
      }
    }
    const s = {
      get value() {
        if (isDestroyed) {
          return value;
        }
        if (activeContext && !isDestroyed) {
          activeContext._accessedStates.add(s);
        }
        return value;
      },
      set value(newVal) {
        if (isDestroyed) {
          return;
        }
        if (newVal === value)
          return;
        if (newVal !== null && typeof newVal === "object") {
          if ("__proto__" in newVal || "constructor" in newVal || "prototype" in newVal) {
            if (Array.isArray(newVal)) {
              newVal = [...newVal];
            } else {
              newVal = { ...newVal };
              delete newVal.__proto__;
              delete newVal.constructor;
              delete newVal.prototype;
            }
          }
        }
        value = newVal;
        const subsArray = Array.from(subscribers);
        subsArray.forEach((fn) => {
          try {
            fn(newVal);
          } catch (err) {
            console.error("[nixState] Subscriber error:", err);
            subscribers.delete(fn);
          }
        });
      },
      subscribe(fn) {
        if (typeof fn !== "function") {
          console.error("[nixState] subscribe() requires a function");
          return () => {
          };
        }
        if (isDestroyed) {
          console.warn("[nixState] Cannot subscribe to destroyed state");
          return () => {
          };
        }
        const MAX_SUBSCRIBERS = 1e3;
        if (subscribers.size >= MAX_SUBSCRIBERS) {
          console.error("[nixState] Maximum subscriber limit reached");
          return () => {
          };
        }
        subscribers.add(fn);
        return () => {
          subscribers.delete(fn);
        };
      },
      cleanup() {
        if (isDestroyed)
          return;
        isDestroyed = true;
        subscribers.clear();
        if (value !== null && typeof value === "object") {
          if (Array.isArray(value)) {
            value = [];
          } else {
            value = null;
          }
        }
        console.log("[nixState] State cleaned up");
      },
      getSubscriberCount() {
        return subscribers.size;
      },
      isDestroyed() {
        return isDestroyed;
      },
      asReadOnly() {
        return {
          get value() {
            return s.value;
          },
          subscribe: s.subscribe.bind(s),
          _isNixState: true,
          _isReadOnly: true
        };
      },
      _isNixState: true
    };
    ctx.hooks[idx] = s;
    if (ctx.stateCleanups) {
      ctx.stateCleanups.push(() => s.cleanup());
    }
  }
  return ctx.hooks[idx];
}

// node_modules/fynixui/dist/hooks/nixAsync.js
function nixAsync(promiseFactory, options = {}) {
  const { timeout = 3e4, retries = 0, autoRun = false } = options;
  if (typeof promiseFactory !== "function") {
    throw new TypeError("[nixAsync] promiseFactory must be a function");
  }
  const data = nixState(null);
  const error = nixState(null);
  const loading = nixState(false);
  let active = true;
  let controller = null;
  let callId = 0;
  let timeoutId = null;
  let retryCount = 0;
  const cleanup = () => {
    active = false;
    if (controller) {
      controller.abort();
      controller = null;
    }
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
    callId = 0;
    retryCount = 0;
  };
  const run = async () => {
    if (!active) {
      console.warn("[nixAsync] Attempted to run on destroyed async hook");
      return;
    }
    if (controller) {
      controller.abort();
    }
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    controller = new AbortController();
    const signal = controller.signal;
    const currentCallId = ++callId;
    retryCount = 0;
    loading.value = true;
    error.value = null;
    if (timeout > 0) {
      timeoutId = setTimeout(() => {
        if (controller && currentCallId === callId) {
          controller.abort();
          if (active && currentCallId === callId) {
            error.value = new Error(`Request timeout after ${timeout}ms`);
            loading.value = false;
          }
        }
      }, timeout);
    }
    try {
      const result = await promiseFactory(signal);
      if (!active || currentCallId !== callId || signal.aborted) {
        return;
      }
      data.value = result;
      retryCount = 0;
    } catch (e) {
      if (!active || currentCallId !== callId) {
        return;
      }
      if (signal.aborted) {
        return;
      }
      const errorInstance = e instanceof Error ? e : new Error(String(e));
      if (retryCount < retries && active && currentCallId === callId) {
        retryCount++;
        console.warn(`[nixAsync] Retrying (${retryCount}/${retries}):`, errorInstance.message);
        const retryDelay = Math.min(1e3 * Math.pow(2, retryCount - 1), 1e4);
        setTimeout(() => {
          if (active && currentCallId === callId) {
            run();
          }
        }, retryDelay);
        return;
      }
      error.value = errorInstance;
    } finally {
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      if (active && currentCallId === callId && !signal.aborted) {
        loading.value = false;
      }
    }
  };
  const cancel = () => {
    if (controller) {
      controller.abort();
    }
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
    loading.value = false;
    retryCount = 0;
  };
  const getCallId = () => callId;
  if (autoRun) {
    setTimeout(() => {
      if (active)
        run();
    }, 0);
  }
  return { data, error, loading, run, cancel, cleanup, getCallId };
}

// node_modules/fynixui/dist/hooks/nixAsyncCache.js
var asyncCache = /* @__PURE__ */ new Map();
var CACHE_CLEANUP_INTERVAL = 6e4;
var cacheCleanupTimer = null;
var startCacheCleanup = () => {
  if (cacheCleanupTimer)
    return;
  cacheCleanupTimer = setInterval(() => {
    const now = Date.now();
    const entries = Array.from(asyncCache.entries());
    for (const [key, entry] of entries) {
      if (entry.timestamp && entry.ttl && now - entry.timestamp > entry.ttl) {
        asyncCache.delete(key);
      }
    }
    if (asyncCache.size === 0 && cacheCleanupTimer) {
      clearInterval(cacheCleanupTimer);
      cacheCleanupTimer = null;
    }
  }, CACHE_CLEANUP_INTERVAL);
};
function nixAsyncCached(key, promiseFactory, options = {}) {
  if (!promiseFactory || typeof promiseFactory !== "function") {
    throw new Error("[nixAsyncCache] promiseFactory must be a function");
  }
  if (key == null) {
    throw new Error("[nixAsyncCache] Key cannot be null or undefined");
  }
  if (options.validateKey && !options.validateKey(key)) {
    throw new Error("[nixAsyncCache] Invalid cache key");
  }
  const { ttl = 3e5, maxCacheSize = 100 } = options;
  if (asyncCache.size >= maxCacheSize) {
    const entries = Array.from(asyncCache.entries());
    const entriesToRemove = Math.max(1, Math.floor(maxCacheSize * 0.1));
    for (let i = 0; i < entriesToRemove; i++) {
      const entry = entries[i];
      if (entry) {
        asyncCache.delete(entry[0]);
      }
    }
  }
  const data = nixState(null);
  const error = nixState(null);
  const loading = nixState(false);
  let active = true;
  let abortController = null;
  startCacheCleanup();
  const run = async () => {
    if (!active)
      return;
    if (abortController) {
      abortController.abort();
    }
    abortController = new AbortController();
    loading.value = true;
    error.value = null;
    try {
      if (asyncCache.has(key)) {
        const cached = asyncCache.get(key);
        const now = Date.now();
        if (cached.timestamp && now - cached.timestamp > ttl) {
          asyncCache.delete(key);
        } else if (cached.data !== void 0) {
          data.value = cached.data;
          loading.value = false;
          return;
        }
        if (cached.promise) {
          try {
            const result2 = await cached.promise;
            if (!active || abortController?.signal.aborted)
              return;
            data.value = result2;
            loading.value = false;
            return;
          } catch (e) {
            if (!active || abortController?.signal.aborted)
              return;
            error.value = e;
            loading.value = false;
            return;
          }
        }
      }
      const promise = Promise.resolve().then(() => {
        if (abortController?.signal.aborted) {
          throw new Error("Request was aborted");
        }
        return promiseFactory();
      });
      asyncCache.set(key, {
        promise,
        timestamp: Date.now(),
        ttl
      });
      const result = await promise;
      if (!active || abortController?.signal.aborted)
        return;
      asyncCache.set(key, {
        data: result,
        timestamp: Date.now(),
        ttl
      });
      data.value = result;
    } catch (e) {
      if (asyncCache.has(key)) {
        const cached = asyncCache.get(key);
        if (cached.promise && !cached.data) {
          asyncCache.delete(key);
        }
      }
      if (!active || abortController?.signal.aborted)
        return;
      error.value = e;
    } finally {
      if (active && !abortController?.signal.aborted) {
        loading.value = false;
      }
    }
  };
  const cancel = () => {
    active = false;
    if (abortController) {
      abortController.abort();
      abortController = null;
    }
  };
  const clearCache = () => {
    asyncCache.delete(key);
  };
  return { data, error, loading, run, cancel, clearCache };
}

// node_modules/fynixui/dist/hooks/nixAsyncDebounce.js
function nixAsyncDebounce(promiseFactory, options = {}) {
  const data = nixState(null);
  const error = nixState(null);
  const loading = nixState(false);
  const { delay = 300, leading = false, trailing = true, maxWait, cache = true, signal } = options;
  let lastResult = null;
  let lastError = null;
  let timerId = null;
  let lastInvokeTime = 0;
  let pendingPromise = null;
  const invoke = async () => {
    if (cache && lastResult !== null) {
      data.value = lastResult;
      error.value = lastError;
      loading.value = false;
      return lastResult;
    }
    loading.value = true;
    error.value = null;
    const abortController = new AbortController();
    if (signal) {
      signal.addEventListener("abort", () => {
        abortController.abort();
        cancel();
      });
    }
    pendingPromise = promiseFactory();
    try {
      const result = await pendingPromise;
      lastResult = result;
      data.value = result;
      return result;
    } catch (e) {
      if (e.name !== "AbortError") {
        lastError = e;
        error.value = e;
      }
      throw e;
    } finally {
      loading.value = false;
      pendingPromise = null;
      lastInvokeTime = Date.now();
    }
  };
  const run = () => {
    const now = Date.now();
    const timeSinceLastInvoke = now - lastInvokeTime;
    const remainingTime = delay - timeSinceLastInvoke;
    const shouldInvokeLeading = leading && !timerId;
    if (maxWait !== void 0 && timeSinceLastInvoke >= maxWait) {
      if (timerId)
        clearTimeout(timerId);
      timerId = null;
      return invoke();
    }
    if (timerId)
      clearTimeout(timerId);
    if (shouldInvokeLeading)
      return invoke();
    if (trailing) {
      timerId = setTimeout(() => {
        timerId = null;
        invoke();
      }, remainingTime > 0 ? remainingTime : delay);
    }
  };
  const cancel = () => {
    if (timerId)
      clearTimeout(timerId);
    timerId = null;
    pendingPromise = null;
  };
  return { data, error, loading, run, cancel };
}

// node_modules/fynixui/dist/hooks/nixAsyncQuery.js
var asyncCache2 = /* @__PURE__ */ new Map();
function nixAsyncQuery(key, queryFn, options = {}) {
  const data = nixState(null);
  const error = nixState(null);
  const loading = nixState(false);
  const ttl = options.ttl ?? 0;
  let active = true;
  let callId = 0;
  const run = async () => {
    const id = ++callId;
    loading.value = true;
    error.value = null;
    const now = Date.now();
    const cached = asyncCache2.get(key);
    if (cached?.data && (!ttl || typeof cached.timestamp === "number" && now - cached.timestamp < ttl)) {
      data.value = cached.data;
      loading.value = false;
      return;
    }
    if (cached?.promise) {
      try {
        const result = await cached.promise;
        if (!active || id !== callId)
          return;
        const safeResult = typeof result === "object" && result !== null ? JSON.parse(JSON.stringify(result)) : result;
        data.value = safeResult;
      } catch (e) {
        if (!active || id !== callId)
          return;
        error.value = e instanceof Error ? e : new Error(String(e));
      } finally {
        if (active && id === callId)
          loading.value = false;
      }
      return;
    }
    const controller = new AbortController();
    const promise = (async () => {
      try {
        const result = await queryFn(controller.signal);
        asyncCache2.set(key, {
          data: result,
          timestamp: Date.now()
        });
        return result;
      } catch (e) {
        asyncCache2.delete(key);
        throw e instanceof Error ? e : new Error(String(e));
      }
    })();
    asyncCache2.set(key, { promise, controller });
    try {
      const result = await promise;
      if (!active || id !== callId)
        return;
      const safeResult = typeof result === "object" && result !== null ? JSON.parse(JSON.stringify(result)) : result;
      data.value = safeResult;
    } catch (e) {
      if (!active || id !== callId)
        return;
      error.value = e instanceof Error ? e : new Error(String(e));
    } finally {
      if (active && id === callId)
        loading.value = false;
    }
  };
  const cancel = () => {
    active = false;
    const cached = asyncCache2.get(key);
    if (cached?.controller) {
      cached.controller.abort();
    }
  };
  return { data, error, loading, run, cancel };
}

// node_modules/fynixui/dist/hooks/nixCallback.js
function nixCallback(fn, deps = []) {
  const ctx = activeContext;
  if (!ctx)
    throw new Error("nixCallback() called outside component");
  if (typeof fn !== "function") {
    console.error("[nixCallback] First argument must be a function");
    return fn;
  }
  if (!Array.isArray(deps)) {
    console.error("[nixCallback] Second argument must be an array");
    deps = [];
  }
  const MAX_DEPS = 100;
  if (deps.length > MAX_DEPS) {
    console.warn(`[nixCallback] Dependency array too large (${deps.length}). Limited to ${MAX_DEPS}.`);
    deps = deps.slice(0, MAX_DEPS);
  }
  const idx = ctx.hookIndex++;
  const prev = ctx.hooks[idx];
  if (!prev || !shallowArrayEqual(prev.deps, deps)) {
    ctx.hooks[idx] = { value: fn, deps };
  }
  return ctx.hooks[idx].value;
}
function shallowArrayEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    if (!Object.is(a[i], b[i]))
      return false;
  }
  return true;
}

// node_modules/fynixui/dist/hooks/nixComputed.js
function nixComputed(computeFn) {
  const ctx = activeContext;
  if (!ctx)
    throw new Error("nixComputed() called outside component");
  if (typeof computeFn !== "function") {
    throw new TypeError("[nixComputed] First argument must be a function");
  }
  const idx = ctx.hookIndex++;
  if (!ctx.hooks[idx]) {
    let compute = function() {
      if (isDestroyed)
        return cachedValue;
      if (isComputing) {
        console.error("[nixComputed] Circular dependency detected");
        return cachedValue;
      }
      isComputing = true;
      const trackingContext = {
        _accessedStates: /* @__PURE__ */ new Set(),
        hookIndex: 0,
        hooks: [],
        _subscriptions: /* @__PURE__ */ new Set(),
        _subscriptionCleanups: [],
        effects: [],
        cleanups: [],
        _vnode: null,
        version: 0,
        props: {},
        stateCleanups: [],
        parent: null,
        context: {},
        rerender: () => {
        },
        Component: null,
        _isMounted: false,
        _isRerendering: false
      };
      const prevContext = activeContext;
      try {
        setActiveContext(trackingContext);
        cachedValue = computeFn();
        const oldDeps = Array.from(dependencies);
        oldDeps.forEach((dep) => {
          if (!trackingContext._accessedStates.has(dep)) {
            if (unsubscribers.has(dep)) {
              try {
                unsubscribers.get(dep)();
              } catch (e) {
                console.error("[nixComputed] Error unsubscribing from old dependency:", e);
              }
              unsubscribers.delete(dep);
            }
            dependencies.delete(dep);
          }
        });
        trackingContext._accessedStates.forEach((state) => {
          if (!dependencies.has(state)) {
            const unsub = state.subscribe(() => {
              if (isDestroyed)
                return;
              isStale = true;
              const newValue = s.value;
              const subsArray = Array.from(subscribers);
              subsArray.forEach((fn) => {
                try {
                  fn(newValue);
                } catch (e) {
                  console.error("[nixComputed] Subscriber error:", e);
                  subscribers.delete(fn);
                }
              });
            });
            unsubscribers.set(state, unsub);
            dependencies.add(state);
          }
        });
        isStale = false;
      } catch (err) {
        console.error("[nixComputed] Compute error:", err);
        isStale = false;
      } finally {
        setActiveContext(prevContext);
        isComputing = false;
      }
      return cachedValue;
    };
    const subscribers = /* @__PURE__ */ new Set();
    const dependencies = /* @__PURE__ */ new Set();
    const unsubscribers = /* @__PURE__ */ new Map();
    let cachedValue;
    let isStale = true;
    let isDestroyed = false;
    let isComputing = false;
    const s = {
      get value() {
        if (isDestroyed) {
          console.warn("[nixComputed] Accessing destroyed computed state");
          return cachedValue;
        }
        if (isStale) {
          compute();
        }
        if (activeContext && activeContext._accessedStates) {
          activeContext._accessedStates.add(s);
        }
        return cachedValue;
      },
      subscribe(fn) {
        if (typeof fn !== "function") {
          console.error("[nixComputed] subscribe() requires a function");
          return () => {
          };
        }
        if (isDestroyed) {
          console.warn("[nixComputed] Cannot subscribe to destroyed computed state");
          return () => {
          };
        }
        const MAX_SUBSCRIBERS = 1e3;
        if (subscribers.size >= MAX_SUBSCRIBERS) {
          console.error("[nixComputed] Maximum subscriber limit reached");
          return () => {
          };
        }
        subscribers.add(fn);
        return () => {
          subscribers.delete(fn);
        };
      },
      cleanup() {
        if (isDestroyed)
          return;
        isDestroyed = true;
        unsubscribers.forEach((unsub) => {
          try {
            unsub();
          } catch (e) {
            console.error("[nixComputed] Cleanup error:", e);
          }
        });
        unsubscribers.clear();
        dependencies.clear();
        subscribers.clear();
        cachedValue = null;
        console.log("[nixComputed] Computed state cleaned up");
      },
      getSubscriberCount() {
        return subscribers.size;
      },
      getDependencyCount() {
        return dependencies.size;
      },
      isDestroyed() {
        return isDestroyed;
      },
      getDependencyInfo() {
        return Array.from(dependencies).map((state) => ({
          state,
          hasCleanup: unsubscribers.has(state),
          isComputed: !!state._isComputed
        }));
      },
      _isNixState: true,
      _isComputed: true
    };
    compute();
    ctx.hooks[idx] = s;
    if (ctx.stateCleanups) {
      ctx.stateCleanups.push(() => s.cleanup());
    }
  }
  return ctx.hooks[idx];
}

// node_modules/fynixui/dist/hooks/nixDebounce.js
function nixDebounce(fn, delay = 300, options = {}) {
  let timerId = null;
  let lastInvokeTime = 0;
  let lastArgs = null;
  let lastThis = null;
  const { leading = false, trailing = true, maxWait, signal } = options;
  if (signal) {
    signal.addEventListener("abort", () => {
      if (timerId) {
        clearTimeout(timerId);
        timerId = null;
      }
      lastArgs = null;
      lastThis = null;
    });
  }
  const invoke = () => {
    lastInvokeTime = Date.now();
    if (lastArgs) {
      fn.apply(lastThis, lastArgs);
      lastArgs = lastThis = null;
    }
  };
  const debounced = function(...args) {
    const now = Date.now();
    lastArgs = args;
    lastThis = this;
    const shouldInvokeLeading = leading && !timerId;
    const timeSinceLastInvoke = now - lastInvokeTime;
    const remainingTime = delay - timeSinceLastInvoke;
    if (maxWait !== void 0 && timeSinceLastInvoke >= maxWait) {
      if (timerId)
        clearTimeout(timerId);
      timerId = null;
      invoke();
      return;
    }
    if (timerId)
      clearTimeout(timerId);
    if (shouldInvokeLeading) {
      invoke();
    }
    if (trailing) {
      timerId = setTimeout(invoke, remainingTime > 0 ? remainingTime : delay);
    }
  };
  debounced.cancel = () => {
    if (timerId)
      clearTimeout(timerId);
    timerId = null;
    lastArgs = null;
    lastThis = null;
  };
  return debounced;
}

// node_modules/fynixui/dist/hooks/nixEffect.js
function nixEffect(effect, deps = []) {
  const ctx = activeContext;
  if (!ctx)
    throw new Error("nixEffect() called outside component");
  if (typeof effect !== "function") {
    console.error("[nixEffect] First argument must be a function");
    return;
  }
  if (!Array.isArray(deps)) {
    console.error("[nixEffect] Second argument must be an array");
    deps = [];
  }
  const MAX_DEPS = 100;
  if (deps.length > MAX_DEPS) {
    console.warn(`[nixEffect] Dependency array too large (${deps.length}). Limited to ${MAX_DEPS}.`);
    deps = deps.slice(0, MAX_DEPS);
  }
  const idx = ctx.hookIndex++;
  const prev = ctx.hooks[idx];
  const hasChanged = !prev || !shallowArrayEqual2(prev.deps, deps);
  if (hasChanged) {
    if (prev?.cleanup) {
      try {
        if (typeof prev.cleanup === "function") {
          prev.cleanup();
        }
      } catch (err) {
        console.error("[nixEffect] Cleanup error:", err);
      }
    }
    let cleanup;
    try {
      cleanup = effect();
      if (cleanup !== void 0 && typeof cleanup !== "function") {
        console.warn("[nixEffect] Effect should return undefined or a cleanup function");
        cleanup = void 0;
      }
    } catch (err) {
      console.error("[nixEffect] Effect error:", err);
      cleanup = void 0;
    }
    ctx.hooks[idx] = { deps, cleanup };
    if (cleanup && typeof cleanup === "function") {
      if (!ctx.cleanups)
        ctx.cleanups = [];
      ctx.cleanups.push(cleanup);
    }
  }
}
function shallowArrayEqual2(arr1, arr2) {
  if (arr1.length !== arr2.length)
    return false;
  for (let i = 0; i < arr1.length; i++) {
    if (!Object.is(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
}
function nixEffectOnce(effect) {
  return nixEffect(effect, []);
}
function nixEffectAlways(effect) {
  const ctx = activeContext;
  if (!ctx)
    throw new Error("nixEffectAlways() called outside component");
  if (typeof effect !== "function") {
    console.error("[nixEffectAlways] Argument must be a function");
    return;
  }
  return nixEffect(effect, [ctx.version]);
}

// node_modules/fynixui/dist/hooks/nixForm.js
function nixForm(initialValues = {}, validationRules = {}) {
  const values = nixState({ ...initialValues });
  const errors = nixState({});
  const touched = nixState({});
  const isSubmitting = nixState(false);
  const isValid = nixComputed(() => Object.keys(errors.value).length === 0);
  let abortController = null;
  function validate(fieldName, value) {
    const rules = validationRules[fieldName];
    if (!rules)
      return null;
    if (rules.required && !value) {
      return rules.message || `${String(fieldName)} is required`;
    }
    if (rules.minLength && value.length < rules.minLength) {
      return rules.message || `${String(fieldName)} must be at least ${rules.minLength} characters`;
    }
    if (rules.maxLength && value.length > rules.maxLength) {
      return rules.message || `${String(fieldName)} must be at most ${rules.maxLength} characters`;
    }
    if (rules.pattern && !rules.pattern.test(value)) {
      return rules.message || `${String(fieldName)} is invalid`;
    }
    if (rules.custom && !rules.custom(value, values.value)) {
      return rules.message || `${String(fieldName)} is invalid`;
    }
    return null;
  }
  function handleChange(fieldName, value) {
    values.value = { ...values.value, [fieldName]: value };
    if (touched.value[fieldName]) {
      const error = validate(fieldName, value);
      if (error) {
        errors.value = { ...errors.value, [fieldName]: error };
      } else {
        const newErrors = { ...errors.value };
        delete newErrors[fieldName];
        errors.value = newErrors;
      }
    }
  }
  function handleBlur(fieldName) {
    touched.value = { ...touched.value, [fieldName]: true };
    const error = validate(fieldName, values.value[fieldName]);
    if (error) {
      errors.value = { ...errors.value, [fieldName]: error };
    }
  }
  function validateAll() {
    const newErrors = {};
    Object.keys(validationRules).forEach((fieldName) => {
      const error = validate(fieldName, values.value[fieldName]);
      if (error)
        newErrors[fieldName] = error;
    });
    errors.value = newErrors;
    return Object.keys(newErrors).length === 0;
  }
  async function handleSubmit(onSubmit) {
    const allTouched = Object.keys(validationRules).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    touched.value = allTouched;
    if (!validateAll())
      return;
    if (abortController)
      abortController.abort();
    abortController = new AbortController();
    const signal = abortController.signal;
    isSubmitting.value = true;
    try {
      await onSubmit(values.value, signal);
    } catch (err) {
      if (err.name !== "AbortError") {
        console.error("[nixForm] Submission error:", err);
      }
    } finally {
      if (!signal.aborted)
        isSubmitting.value = false;
    }
  }
  function cancelSubmit() {
    if (abortController) {
      abortController.abort();
      abortController = null;
    }
  }
  function reset() {
    values.value = { ...initialValues };
    errors.value = {};
    touched.value = {};
    isSubmitting.value = false;
    cancelSubmit();
  }
  function getFieldProps(fieldName) {
    return {
      value: values.value[fieldName] || "",
      "r-input": (e) => handleChange(fieldName, e.target.value),
      "r-blur": () => handleBlur(fieldName)
    };
  }
  return {
    values,
    errors,
    touched,
    isSubmitting,
    isValid,
    handleChange,
    handleBlur,
    handleSubmit,
    cancelSubmit,
    reset,
    getFieldProps
  };
}

// node_modules/fynixui/dist/hooks/nixFormAsync.js
function nixFormAsync(initialValues = {}, validationRules = {}, options = {}) {
  const values = nixState({ ...initialValues });
  const errors = nixState({});
  const touched = nixState({});
  const isSubmitting = nixState(false);
  const isValid = nixComputed(() => Object.keys(errors.value).length === 0);
  const { delay = 300, leading = false, trailing = true, maxWait, cache = true } = options;
  const data = nixState(null);
  const error = nixState(null);
  const loading = nixState(false);
  let abortController = null;
  let timerId = null;
  let lastInvokeTime = 0;
  let lastResult = null;
  let lastError = null;
  let pendingPromise = null;
  function validate(fieldName, value) {
    const rules = validationRules[fieldName];
    if (!rules)
      return null;
    if (rules.required && !value)
      return rules.message || `${String(fieldName)} is required`;
    if (rules.minLength && value.length < rules.minLength)
      return rules.message || `${String(fieldName)} must be at least ${rules.minLength} characters`;
    if (rules.maxLength && value.length > rules.maxLength)
      return rules.message || `${String(fieldName)} must be at most ${rules.maxLength} characters`;
    if (rules.pattern && !rules.pattern.test(value))
      return rules.message || `${String(fieldName)} is invalid`;
    if (rules.custom && !rules.custom(value, values.value))
      return rules.message || `${String(fieldName)} is invalid`;
    return null;
  }
  function handleChange(fieldName, value) {
    values.value = { ...values.value, [fieldName]: value };
    if (touched.value[fieldName]) {
      const err = validate(fieldName, value);
      if (err)
        errors.value = { ...errors.value, [fieldName]: err };
      else {
        const newErrors = { ...errors.value };
        delete newErrors[fieldName];
        errors.value = newErrors;
      }
    }
  }
  function handleBlur(fieldName) {
    touched.value = { ...touched.value, [fieldName]: true };
    const err = validate(fieldName, values.value[fieldName]);
    if (err)
      errors.value = { ...errors.value, [fieldName]: err };
  }
  function validateAll() {
    const newErrors = {};
    Object.keys(validationRules).forEach((fieldName) => {
      const err = validate(fieldName, values.value[fieldName]);
      if (err)
        newErrors[fieldName] = err;
    });
    errors.value = newErrors;
    return Object.keys(newErrors).length === 0;
  }
  async function invokeAsync(onSubmit) {
    if (cache && lastResult !== null) {
      data.value = lastResult;
      error.value = lastError;
      loading.value = false;
      return lastResult;
    }
    if (abortController)
      abortController.abort();
    abortController = new AbortController();
    const signal = abortController.signal;
    loading.value = true;
    error.value = null;
    pendingPromise = onSubmit(values.value, signal);
    try {
      const result = await pendingPromise;
      lastResult = result;
      data.value = result;
      return result;
    } catch (err) {
      if (err.name !== "AbortError") {
        lastError = err;
        error.value = err;
        console.error("[nixFormAsync] submit error:", err);
      }
      throw err;
    } finally {
      loading.value = false;
      pendingPromise = null;
      lastInvokeTime = Date.now();
    }
  }
  function handleSubmit(onSubmit) {
    if (!validateAll())
      return;
    const now = Date.now();
    const timeSinceLastInvoke = now - lastInvokeTime;
    const remainingTime = delay - timeSinceLastInvoke;
    const shouldInvokeLeading = leading && !timerId;
    if (maxWait !== void 0 && timeSinceLastInvoke >= maxWait) {
      if (timerId)
        clearTimeout(timerId);
      timerId = null;
      void invokeAsync(onSubmit);
      return;
    }
    if (timerId)
      clearTimeout(timerId);
    if (shouldInvokeLeading) {
      void invokeAsync(onSubmit);
      return;
    }
    if (trailing) {
      timerId = setTimeout(() => {
        timerId = null;
        void invokeAsync(onSubmit);
      }, remainingTime > 0 ? remainingTime : delay);
    }
  }
  function cancelSubmit() {
    if (abortController) {
      abortController.abort();
      abortController = null;
    }
    if (timerId)
      clearTimeout(timerId);
    timerId = null;
  }
  function reset() {
    values.value = { ...initialValues };
    errors.value = {};
    touched.value = {};
    isSubmitting.value = false;
    cancelSubmit();
    data.value = null;
    error.value = null;
    loading.value = false;
  }
  function getFieldProps(fieldName) {
    return {
      value: values.value[fieldName] || "",
      "r-input": (e) => handleChange(fieldName, e.target.value),
      "r-blur": () => handleBlur(fieldName)
    };
  }
  return {
    values,
    errors,
    touched,
    isSubmitting,
    isValid,
    data,
    error,
    loading,
    handleChange,
    handleBlur,
    handleSubmit,
    cancelSubmit,
    reset,
    getFieldProps
  };
}

// node_modules/fynixui/dist/hooks/nixInterval.js
function nixInterval(fn, ms, signal) {
  if (typeof fn !== "function") {
    throw new TypeError("nixInterval: first argument must be a function");
  }
  if (typeof ms !== "number" || ms < 0) {
    throw new TypeError("nixInterval: second argument must be a non-negative number");
  }
  const id = setInterval(fn, ms);
  const cancel = () => clearInterval(id);
  if (signal) {
    if (signal.aborted) {
      cancel();
    } else {
      const listener = () => {
        cancel();
        signal.removeEventListener("abort", listener);
      };
      signal.addEventListener("abort", listener);
    }
  }
  return cancel;
}

// node_modules/fynixui/dist/hooks/nixLazy.js
function nixLazy(importFn) {
  const cache = {
    status: "pending",
    component: null,
    error: null,
    promise: null
  };
  let canceled = false;
  cache.promise = importFn().then((module) => {
    if (!canceled) {
      cache.status = "success";
      cache.component = module.default || module;
    }
  }).catch((err) => {
    if (!canceled) {
      cache.status = "error";
      cache.error = err;
    }
  });
  return function LazyWrapper(props) {
    const ctx = activeContext;
    if (!ctx)
      throw new Error("nixLazy() called outside component");
    if (cache.status === "pending") {
      throw cache.promise;
    }
    if (cache.status === "error") {
      throw cache.error;
    }
    return cache.component(props);
  };
}
function Suspense({ fallback, children }) {
  const loading = nixState(false);
  const error = nixState(null);
  try {
    return children();
  } catch (promise) {
    if (promise instanceof Promise) {
      loading.value = true;
      promise.then(() => {
        loading.value = false;
      }).catch((err) => {
        error.value = err;
        loading.value = false;
      });
      return fallback;
    }
    throw promise;
  }
}

// node_modules/fynixui/dist/hooks/nixLazyAsync.js
function nixLazyAsync(importFn, options = {}) {
  const { retry = 0 } = options;
  const cache = {
    status: "pending",
    component: null,
    error: null,
    promise: null,
    retriesLeft: retry
  };
  let canceled = false;
  const loadModule = () => {
    cache.promise = importFn().then((module) => {
      if (!canceled) {
        cache.status = "success";
        cache.component = module.default || module;
      }
      return cache.component;
    }).catch((err) => {
      if (!canceled) {
        if (cache.retriesLeft > 0) {
          cache.retriesLeft--;
          return loadModule();
        }
        cache.status = "error";
        cache.error = err;
      }
      return Promise.reject(cache.error);
    });
    return cache.promise;
  };
  loadModule();
  return function LazyWrapper(props) {
    const ctx = activeContext;
    if (!ctx)
      throw new Error("nixLazyAsync() called outside component");
    if (cache.status === "pending") {
      throw cache.promise;
    }
    if (cache.status === "error") {
      throw cache.error;
    }
    if (!cache.component) {
      throw new Error("nixLazyAsync: component not loaded");
    }
    return cache.component(props);
  };
}

// node_modules/fynixui/dist/hooks/nixLazyFormAsync.js
function nixLazyFormAsync(importFn, formOptions = {}, submitOptions = {}, lazyOptions = {}) {
  const { initialValues = {}, validationRules = {} } = formOptions;
  const { retry = 0 } = lazyOptions;
  const { delay = 300, leading = false, trailing = true, maxWait, cache = true } = submitOptions;
  const lazyCache = {
    status: "pending",
    component: null,
    error: null,
    promise: null,
    retriesLeft: retry
  };
  let lazyAbortController = new AbortController();
  let lazyCanceled = false;
  const loadLazy = () => {
    lazyCache.promise = importFn().then((module) => {
      if (!lazyCanceled) {
        lazyCache.status = "success";
        lazyCache.component = module.default || module;
      }
    }).catch((err) => {
      if (!lazyCanceled) {
        if (lazyCache.retriesLeft > 0) {
          lazyCache.retriesLeft--;
          return loadLazy();
        }
        lazyCache.status = "error";
        lazyCache.error = err;
      }
      return Promise.reject(err);
    });
    return lazyCache.promise;
  };
  loadLazy();
  const cancelLazyLoad = () => {
    lazyCanceled = true;
    if (lazyAbortController) {
      lazyAbortController.abort();
      lazyAbortController = null;
    }
  };
  const LazyComponentWrapper = (props) => {
    const ctx = activeContext;
    if (!ctx)
      throw new Error("nixLazyFormAsync: called outside component");
    if (lazyCache.status === "pending")
      throw lazyCache.promise;
    if (lazyCache.status === "error")
      throw lazyCache.error;
    return lazyCache.component(props);
  };
  const values = nixState({ ...initialValues });
  const errors = nixState({});
  const touched = nixState({});
  const isSubmitting = nixState(false);
  const isValid = nixComputed(() => Object.keys(errors.value).length === 0);
  const data = nixState(null);
  const error = nixState(null);
  const loading = nixState(false);
  let abortController = null;
  let timerId = null;
  let lastInvokeTime = 0;
  let lastResult = null;
  let lastError = null;
  let pendingPromise = null;
  function validate(fieldName, value) {
    const rules = validationRules[fieldName];
    if (!rules)
      return null;
    if (rules.required && !value)
      return rules.message || `${String(fieldName)} is required`;
    if (rules.minLength && value.length < rules.minLength)
      return rules.message || `${String(fieldName)} must be at least ${rules.minLength} characters`;
    if (rules.maxLength && value.length > rules.maxLength)
      return rules.message || `${String(fieldName)} must be at most ${rules.maxLength} characters`;
    if (rules.pattern && !rules.pattern.test(value))
      return rules.message || `${String(fieldName)} is invalid`;
    if (rules.custom && !rules.custom(value, values.value))
      return rules.message || `${String(fieldName)} is invalid`;
    return null;
  }
  function handleChange(fieldName, value) {
    values.value = { ...values.value, [fieldName]: value };
    if (touched.value[fieldName]) {
      const err = validate(fieldName, value);
      if (err)
        errors.value = { ...errors.value, [fieldName]: err };
      else {
        const newErrors = { ...errors.value };
        delete newErrors[fieldName];
        errors.value = newErrors;
      }
    }
  }
  function handleBlur(fieldName) {
    touched.value = { ...touched.value, [fieldName]: true };
    const err = validate(fieldName, values.value[fieldName]);
    if (err)
      errors.value = { ...errors.value, [fieldName]: err };
  }
  function validateAll() {
    const newErrors = {};
    Object.keys(validationRules).forEach((fieldName) => {
      const err = validate(fieldName, values.value[fieldName]);
      if (err)
        newErrors[fieldName] = err;
    });
    errors.value = newErrors;
    return Object.keys(newErrors).length === 0;
  }
  async function invokeAsync(onSubmit) {
    if (cache && lastResult !== null) {
      data.value = lastResult ?? null;
      error.value = lastError ?? null;
      loading.value = false;
      return lastResult;
    }
    if (abortController)
      abortController.abort();
    abortController = new AbortController();
    const signal = abortController.signal;
    loading.value = true;
    error.value = null;
    pendingPromise = onSubmit(values.value, signal);
    try {
      const result = await pendingPromise;
      lastResult = result;
      data.value = result ?? null;
      return result;
    } catch (err) {
      if (err.name !== "AbortError") {
        lastError = err;
        error.value = err;
      }
      throw err;
    } finally {
      loading.value = false;
      pendingPromise = null;
      lastInvokeTime = Date.now();
    }
  }
  function handleSubmit(onSubmit) {
    if (!validateAll())
      return;
    const now = Date.now();
    const timeSinceLastInvoke = now - lastInvokeTime;
    const remainingTime = delay - timeSinceLastInvoke;
    const shouldInvokeLeading = leading && !timerId;
    if (maxWait !== void 0 && timeSinceLastInvoke >= maxWait) {
      if (timerId)
        clearTimeout(timerId);
      timerId = null;
      void invokeAsync(onSubmit);
      return;
    }
    if (timerId)
      clearTimeout(timerId);
    if (shouldInvokeLeading) {
      void invokeAsync(onSubmit);
      return;
    }
    if (trailing) {
      timerId = setTimeout(() => {
        timerId = null;
        void invokeAsync(onSubmit);
      }, remainingTime > 0 ? remainingTime : delay);
    }
  }
  function cancelSubmit() {
    if (abortController) {
      abortController.abort();
      abortController = null;
    }
    if (timerId)
      clearTimeout(timerId);
    timerId = null;
  }
  function reset() {
    values.value = { ...initialValues };
    errors.value = {};
    touched.value = {};
    isSubmitting.value = false;
    cancelSubmit();
    cancelLazyLoad();
    data.value = null;
    error.value = null;
    loading.value = false;
  }
  function getFieldProps(fieldName) {
    return {
      value: values.value[fieldName] || "",
      "r-input": (e) => handleChange(fieldName, e.target.value),
      "r-blur": () => handleBlur(fieldName)
    };
  }
  return {
    LazyComponentWrapper,
    values,
    errors,
    touched,
    isSubmitting,
    isValid,
    data,
    error,
    loading,
    handleChange,
    handleBlur,
    handleSubmit,
    cancelSubmit,
    reset,
    getFieldProps
  };
}

// node_modules/fynixui/dist/hooks/nixLocalStorage.js
function safeJSONParse(value, fallback) {
  if (value === null || value === void 0) {
    return fallback;
  }
  try {
    if (typeof value !== "string") {
      console.warn("[nixLocalStorage] Non-string value provided to JSON.parse");
      return fallback;
    }
    const suspiciousPatterns = [
      /__proto__/,
      /constructor/,
      /prototype/,
      /function\s*\(/,
      /=>\s*{/,
      /javascript:/,
      /<script/i
    ];
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(value)) {
        console.warn("[nixLocalStorage] Potentially malicious content detected, using fallback");
        return fallback;
      }
    }
    const parsed = JSON.parse(value);
    if (parsed && typeof parsed === "object") {
      if (parsed.constructor !== Object && parsed.constructor !== Array) {
        console.warn("[nixLocalStorage] Unsafe object constructor detected");
        return fallback;
      }
    }
    return parsed;
  } catch (error) {
    console.warn("[nixLocalStorage] JSON parsing failed:", error);
    return fallback;
  }
}
function safeJSONStringify(value, maxSize = 1024 * 1024) {
  try {
    const stringified = JSON.stringify(value);
    if (stringified.length > maxSize) {
      console.warn("[nixLocalStorage] Value too large to store:", stringified.length, "characters");
      return null;
    }
    return stringified;
  } catch (error) {
    console.warn("[nixLocalStorage] JSON stringification failed:", error);
    return null;
  }
}
function nixLocalStorage(key, initial) {
  if (!key || typeof key !== "string") {
    throw new Error("[nixLocalStorage] Key must be a non-empty string");
  }
  if (key.length > 100) {
    throw new Error("[nixLocalStorage] Key too long (max 100 characters)");
  }
  let initialValue;
  let isStorageValid = true;
  try {
    if (typeof localStorage === "undefined") {
      console.warn("[nixLocalStorage] localStorage not available, using in-memory fallback");
      isStorageValid = false;
      initialValue = initial;
    } else {
      const stored = localStorage.getItem(key);
      initialValue = safeJSONParse(stored, initial);
    }
  } catch (err) {
    console.error(`[nixLocalStorage] Error reading key "${key}":`, err);
    initialValue = initial;
    isStorageValid = false;
  }
  const state = nixState(initialValue);
  const set = (v) => {
    if (!isStorageValid) {
      state.value = v;
      return false;
    }
    try {
      const stringified = safeJSONStringify(v);
      if (stringified === null) {
        console.error(`[nixLocalStorage] Failed to stringify value for key "${key}"`);
        return false;
      }
      localStorage.setItem(key, stringified);
      state.value = v;
      return true;
    } catch (err) {
      console.error(`[nixLocalStorage] Error setting key "${key}":`, err);
      state.value = v;
      return false;
    }
  };
  const clear = () => {
    try {
      if (isStorageValid) {
        localStorage.removeItem(key);
      }
      state.value = initial;
    } catch (err) {
      console.error(`[nixLocalStorage] Error clearing key "${key}":`, err);
    }
  };
  const getSize = () => {
    try {
      if (!isStorageValid)
        return 0;
      const stored = localStorage.getItem(key);
      return stored ? stored.length : 0;
    } catch {
      return 0;
    }
  };
  const isValid = () => isStorageValid;
  return {
    get value() {
      return state.value;
    },
    set value(v) {
      set(v);
    },
    set,
    clear,
    getSize,
    isValid
  };
}

// node_modules/fynixui/dist/hooks/nixMemo.js
function nixMemo(factory, deps = []) {
  const ctx = activeContext;
  if (!ctx)
    throw new Error("nixMemo() called outside component");
  if (typeof factory !== "function") {
    console.error("[nixMemo] First argument must be a function");
    return void 0;
  }
  if (!Array.isArray(deps)) {
    console.error("[nixMemo] Second argument must be an array");
    deps = [];
  }
  const idx = ctx.hookIndex++;
  const prev = ctx.hooks[idx];
  const hasChanged = !prev || prev.deps.length !== deps.length || deps.some((dep, i) => !Object.is(dep, prev.deps[i]));
  if (hasChanged) {
    try {
      const value = factory();
      ctx.hooks[idx] = { value, deps: [...deps] };
    } catch (err) {
      console.error("[nixMemo] Factory function error:", err);
      ctx.hooks[idx] = { value: void 0, deps: [...deps] };
    }
  }
  return ctx.hooks[idx]?.value;
}

// node_modules/fynixui/dist/hooks/nixPrevious.js
function nixPrevious(val) {
  const ctx = activeContext;
  if (!ctx)
    throw new Error("nixPrevious() called outside component");
  const idx = ctx.hookIndex++;
  const prev = ctx.hooks[idx]?.value;
  try {
    ctx.hooks[idx] = { value: val };
  } catch (err) {
    console.error("[nixPrevious] Error storing value:", err);
  }
  return prev;
}

// node_modules/fynixui/dist/hooks/nixRef.js
function nixRef(initial = null) {
  const ctx = activeContext;
  if (!ctx)
    throw new Error("nixRef() called outside component");
  const idx = ctx.hookIndex++;
  if (!ctx.hooks[idx]) {
    try {
      ctx.hooks[idx] = { current: initial };
    } catch (err) {
      console.error("[nixRef] Error initializing ref:", err);
      ctx.hooks[idx] = { current: null };
    }
  }
  return ctx.hooks[idx];
}

// node_modules/fynixui/dist/hooks/nixStore.js
function nixStore(path, initial) {
  if (!path || typeof path !== "string") {
    throw new Error("[nixStore] Path must be a non-empty string");
  }
  const dangerousKeys = ["__proto__", "constructor", "prototype"];
  if (dangerousKeys.some((key) => path.includes(key))) {
    throw new Error("[nixStore] Path contains dangerous keywords");
  }
  if (path.length > 200) {
    throw new Error("[nixStore] Path too long (max 200 characters)");
  }
  const ctx = activeContext;
  if (!ctx)
    throw new Error("nixStore() called outside component");
  const idx = ctx.hookIndex++;
  if (!ctx.hooks[idx]) {
    let value = initial;
    const subscribers = /* @__PURE__ */ new Set();
    let isDestroyed = false;
    let maxSubscribers = 100;
    const s = {
      get value() {
        if (isDestroyed) {
          console.warn("[nixStore] Accessing destroyed store:", path);
          return value;
        }
        try {
          if (activeContext?._accessedStates) {
            activeContext._accessedStates.add(s);
          }
        } catch (err) {
          console.error("[nixStore] Error tracking accessed state:", err);
        }
        return value;
      },
      set value(v) {
        if (isDestroyed) {
          console.warn("[nixStore] Attempting to set value on destroyed store:", path);
          return;
        }
        if (v && typeof v === "object") {
          const safeValue = /* @__PURE__ */ Object.create(null);
          for (const key in v) {
            if (Object.prototype.hasOwnProperty.call(v, key) && !dangerousKeys.includes(key)) {
              safeValue[key] = v[key];
            }
          }
          value = safeValue;
        } else {
          value = v;
        }
        const subscriberArray = Array.from(subscribers);
        subscriberArray.forEach((fn) => {
          try {
            fn();
          } catch (err) {
            console.error("[nixStore] Subscriber error:", err);
            subscribers.delete(fn);
          }
        });
      },
      subscribe(fn) {
        if (isDestroyed) {
          console.warn("[nixStore] Attempting to subscribe to destroyed store:", path);
          return () => {
          };
        }
        if (typeof fn !== "function") {
          console.error("[nixStore] Subscriber must be a function");
          return () => {
          };
        }
        if (subscribers.size >= maxSubscribers) {
          console.warn(`[nixStore] Maximum subscribers (${maxSubscribers}) reached for store:`, path);
          return () => {
          };
        }
        subscribers.add(fn);
        return () => {
          subscribers.delete(fn);
        };
      },
      cleanup() {
        if (isDestroyed)
          return;
        isDestroyed = true;
        subscribers.clear();
        console.debug(`[nixStore] Cleaned up store: ${path}`);
      },
      getSubscriberCount: () => subscribers.size,
      isDestroyed: () => isDestroyed,
      path,
      _isNixState: true
    };
    if (!ctx.cleanups)
      ctx.cleanups = [];
    ctx.cleanups.push(() => s.cleanup());
    ctx.hooks[idx] = s;
  }
  return ctx.hooks[idx];
}

// node_modules/fynixui/dist/router/router.js
var MAX_CACHE_SIZE = 50;
var PROPS_NAMESPACE = "__fynixLinkProps__";
var MAX_LISTENERS = 100;
var ALLOWED_PROTOCOLS = ["http:", "https:", ""];
var RENDER_DEBOUNCE = 10;
var routerInstance = null;
var isRouterInitialized = false;
function isExternal(url) {
  return /^https?:\/\//.test(url);
}
function escapeHTML(str) {
  if (typeof str !== "string")
    return "";
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;").replace(/`/g, "&#96;").replace(/\//g, "&#x2F;").replace(/=/g, "&#x3D;").replace(/\(/g, "&#x28;").replace(/\)/g, "&#x29;").replace(/\{/g, "&#x7B;").replace(/\}/g, "&#x7D;").replace(/\[/g, "&#x5B;").replace(/\]/g, "&#x5D;");
}
function sanitizeContent(content) {
  return content.replace(/<script[^>]*>.*?<\/script>/gis, "").replace(/<iframe[^>]*>.*?<\/iframe>/gis, "").replace(/<object[^>]*>.*?<\/object>/gis, "").replace(/<embed[^>]*>/gi, "").replace(/<link[^>]*>/gi, "").replace(/on\w+\s*=/gi, "").replace(/javascript:/gi, "").replace(/vbscript:/gi, "").replace(/data:/gi, "").replace(/expression\s*\(/gi, "");
}
function sanitizeProps(props) {
  const sanitized = {};
  for (const [key, value] of Object.entries(props)) {
    if (typeof key !== "string" || key.startsWith("__") || key.includes("javascript") || key.includes("on")) {
      continue;
    }
    if (typeof value === "string") {
      const cleanContent = sanitizeContent(value);
      sanitized[key] = escapeHTML(cleanContent);
    } else if (typeof value === "object" && value !== null) {
      if (Object.keys(value).length < 50) {
        sanitized[key] = sanitizeProps(value);
      }
    } else if (typeof value === "number" || typeof value === "boolean") {
      sanitized[key] = value;
    }
  }
  return sanitized;
}
function isValidURL(url) {
  try {
    const suspiciousPatterns = [
      /javascript:/i,
      /vbscript:/i,
      /data:/i,
      /mailto:/i,
      /tel:/i,
      /ftp:/i,
      /file:/i,
      /%2f%2f/i,
      /%5c%5c/i,
      /\\\\/,
      /@/
    ];
    if (suspiciousPatterns.some((pattern) => pattern.test(url))) {
      console.warn("[Router] Security: Suspicious URL pattern blocked");
      return false;
    }
    const parsed = new URL(url, window.location.origin);
    if (parsed.origin !== window.location.origin) {
      console.warn("[Router] Security: Cross-origin navigation blocked");
      return false;
    }
    if (!ALLOWED_PROTOCOLS.includes(parsed.protocol)) {
      console.warn("[Router] Security: Dangerous protocol blocked:", parsed.protocol);
      return false;
    }
    const decodedPath = decodeURIComponent(parsed.pathname);
    if (decodedPath !== parsed.pathname && /[<>"'`]/.test(decodedPath)) {
      console.warn("[Router] Security: Encoded XSS attempt blocked");
      return false;
    }
    if (url.length > 2048) {
      console.warn("[Router] Security: Excessively long URL blocked");
      return false;
    }
    return true;
  } catch (e) {
    console.warn("[Router] Security: Invalid URL blocked");
    return false;
  }
}
function sanitizePath(path) {
  if (typeof path !== "string")
    return "/";
  try {
    path = decodeURIComponent(path);
  } catch (e) {
    console.warn("[Router] Invalid URL encoding in path");
    return "/";
  }
  path = path.replace(/\0/g, "");
  path = path.replace(/\\/g, "/");
  path = path.replace(/\/+/g, "/");
  path = path.split("/").filter((part) => part !== ".." && part !== ".").join("/");
  if (!path.startsWith("/")) {
    path = "/" + path;
  }
  if (path.length > 1 && path.endsWith("/")) {
    path = path.slice(0, -1);
  }
  return path || "/";
}
function tryGlobPaths() {
  try {
    let modules = import.meta.glob("/src/**/*.{fnx,tsx,jsx,ts,js}", {
      eager: true
    });
    if (Object.keys(modules).length === 0) {
      modules = import.meta.glob(["./**/*.fnx", "./**/*.tsx", "./**/*.jsx", "./**/*.ts", "./**/*.js"], { eager: true });
    }
    if (Object.keys(modules).length === 0) {
      modules = import.meta.glob(["../**/*.fnx", "../**/*.tsx", "../**/*.jsx"], { eager: true });
    }
    return modules || {};
  } catch (error) {
    console.error("[Router] Failed to load modules:", error);
    return {};
  }
}
function filePathToRoute(filePath) {
  let route = filePath.replace(/^.*\/src/, "").replace(/\.(ts|tsx|js|jsx|fnx)$/, "").replace(/\/view$/, "").replace(/\/$/, "");
  if (!route)
    route = "/";
  route = route.replace(/\[([^\]]+)\]/g, ":$1");
  return route;
}
function matchDynamicRoute(path, dynamicRoutes) {
  for (const route of dynamicRoutes) {
    const match = path.match(route.regex);
    if (match) {
      const params = {};
      route.params.forEach((param, i) => {
        const matchValue = match[i + 1];
        params[param] = escapeHTML(matchValue || "");
      });
      return { component: route.component, params };
    }
  }
  return null;
}
function deserializeProps(props) {
  if (!props || typeof props !== "object")
    return {};
  const deserialized = {};
  for (const [key, value] of Object.entries(props)) {
    if (typeof key !== "string" || key.startsWith("__")) {
      continue;
    }
    deserialized[key] = value;
  }
  return deserialized;
}
function normalizePath(path) {
  return sanitizePath(path);
}
function generateCacheKey() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `${Date.now()}-${Math.random().toString(36).slice(2)}-${Math.random().toString(36).slice(2)}`;
}
function addToCache(cache, key, value) {
  if (cache.size >= MAX_CACHE_SIZE) {
    const firstKey = cache.keys().next().value;
    if (typeof firstKey === "string") {
      const evicted = cache.get(firstKey);
      if (evicted && typeof evicted === "object") {
        Object.values(evicted).forEach((val) => {
          if (val && typeof val === "object" && "cleanup" in val) {
            try {
              val.cleanup();
            } catch (e) {
            }
          }
        });
      }
      cache.delete(firstKey);
    }
  }
  cache.set(key, value);
}
var MANAGED_META = [
  { key: "description", name: "description" },
  { key: "keywords", name: "keywords" },
  { key: "twitterCard", name: "twitter:card" },
  { key: "ogTitle", property: "og:title" },
  { key: "ogDescription", property: "og:description" },
  { key: "ogImage", property: "og:image" }
];
function updateMetaTags(meta = {}) {
  if (!meta || typeof meta !== "object")
    return;
  if (meta.title && typeof meta.title === "string") {
    const sanitizedTitle = escapeHTML(meta.title).substring(0, 60);
    document.title = sanitizedTitle;
  }
  MANAGED_META.forEach((def) => {
    const value = meta[def.key];
    const selector = def.name ? `meta[name="${CSS.escape(def.name)}"]` : `meta[property="${CSS.escape(def.property || "")}"]`;
    let el = document.querySelector(selector);
    if (value == null) {
      if (el)
        el.remove();
      return;
    }
    if (typeof value !== "string")
      return;
    const cleanValue = sanitizeContent(value);
    const sanitizedValue = escapeHTML(cleanValue).substring(0, 300);
    if (/javascript:|vbscript:|data:|<|>/i.test(sanitizedValue)) {
      console.warn(`[Router] Security: Blocked suspicious meta content for ${def.key}`);
      return;
    }
    if (!el) {
      el = document.createElement("meta");
      if (def.name)
        el.setAttribute("name", def.name);
      if (def.property)
        el.setAttribute("property", def.property);
      document.head.appendChild(el);
    }
    el.setAttribute("content", sanitizedValue);
  });
}
var EnterpriseRouter = class {
  constructor() {
    this.routeCache = /* @__PURE__ */ new Map();
    this.preloadQueue = /* @__PURE__ */ new Set();
    this.routeMatchCache = /* @__PURE__ */ new Map();
    this.routes = {};
  }
  setRoutes(routes) {
    if (!routes || typeof routes !== "object") {
      console.warn("[EnterpriseRouter] Invalid routes configuration");
      return;
    }
    this.routes = routes;
  }
  async preloadRoute(path) {
    if (this.routeCache.has(path))
      return;
    const route = this.routes[path];
    if (route?.component) {
      const loadRoute = async () => {
        try {
          const component = await route.component();
          this.routeCache.set(path, component);
          route.prefetch?.forEach((prefetchPath) => {
            this.preloadQueue.add(prefetchPath);
          });
          console.log(`[EnterpriseRouter] Preloaded route: ${path}`);
        } catch (error) {
          console.warn(`[EnterpriseRouter] Failed to preload route ${path}:`, error);
        }
      };
      if ("requestIdleCallback" in window) {
        requestIdleCallback(loadRoute);
      } else {
        setTimeout(loadRoute, 0);
      }
    }
  }
  matchRoute(path) {
    const cached = this.routeMatchCache.get(path);
    if (cached !== void 0)
      return cached;
    const match = this.computeRouteMatch(path);
    if (this.routeMatchCache.size > 100) {
      const firstKey = this.routeMatchCache.keys().next().value;
      if (firstKey !== void 0) {
        this.routeMatchCache.delete(firstKey);
      }
    }
    this.routeMatchCache.set(path, match);
    return match;
  }
  computeRouteMatch(path) {
    const segments = path.split("/").filter(Boolean);
    for (const [routePath, routeConfig] of Object.entries(this.routes)) {
      const routeSegments = routePath.split("/").filter(Boolean);
      if (segments.length !== routeSegments.length)
        continue;
      const params = {};
      let isMatch = true;
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        const routeSegment = routeSegments[i];
        if (routeSegment && segment) {
          if (routeSegment.startsWith(":")) {
            params[routeSegment.slice(1)] = segment;
          } else if (segment !== routeSegment) {
            isMatch = false;
            break;
          }
        } else {
          isMatch = false;
          break;
        }
      }
      if (isMatch) {
        return {
          component: routeConfig.component,
          params,
          meta: typeof routeConfig.meta === "function" ? routeConfig.meta(params) : routeConfig.meta
        };
      }
    }
    return null;
  }
  async checkRouteGuard(route, path, params) {
    if (!route.guard)
      return true;
    if (route.guard.canActivate) {
      const canActivate = await route.guard.canActivate(path, params);
      return canActivate;
    }
    return true;
  }
  getPreloadedComponent(path) {
    return this.routeCache.get(path);
  }
  clearCache() {
    this.routeCache.clear();
    this.routeMatchCache.clear();
    this.preloadQueue.clear();
  }
};
var LayoutRouter = class {
  constructor() {
    this.layoutCache = /* @__PURE__ */ new Map();
    this.keepAliveComponents = /* @__PURE__ */ new Map();
  }
  renderNestedRoutes(routes, segments) {
    if (segments.length === 0)
      return null;
    const [currentSegment, ...remainingSegments] = segments;
    const currentRoute = routes.find((r) => r.path === currentSegment);
    if (!currentRoute)
      return null;
    let content;
    if (remainingSegments.length > 0 && currentRoute.children) {
      content = this.renderNestedRoutes(currentRoute.children, remainingSegments);
    } else {
      if (currentRoute.keepAlive && currentSegment) {
        content = this.renderKeepAlive(currentRoute.component, currentSegment);
      } else {
        content = this.renderComponent(currentRoute.component);
      }
    }
    if (currentRoute.layout) {
      const layoutKey = `${currentSegment}_layout`;
      let layoutComponent = this.layoutCache.get(layoutKey);
      if (!layoutComponent) {
        layoutComponent = this.renderComponent(currentRoute.layout);
        this.layoutCache.set(layoutKey, layoutComponent);
      }
      return this.renderComponent(currentRoute.layout, { children: content });
    }
    return content;
  }
  renderKeepAlive(component, key) {
    if (this.keepAliveComponents.has(key)) {
      return this.keepAliveComponents.get(key);
    }
    const rendered = this.renderComponent(component);
    this.keepAliveComponents.set(key, rendered);
    return rendered;
  }
  renderComponent(component, props = {}) {
    try {
      return component(props);
    } catch (error) {
      console.error("[LayoutRouter] Component render error:", error);
      return null;
    }
  }
  cleanup() {
    this.layoutCache.clear();
    this.keepAliveComponents.clear();
  }
};
var enterpriseRouter = new EnterpriseRouter();
var layoutRouter = new LayoutRouter();
function createFynix() {
  const isDevMode = import.meta.hot !== void 0;
  if (routerInstance && isRouterInitialized && !isDevMode) {
    console.warn("[Router] Router already initialized, returning existing instance");
    return routerInstance;
  }
  if (isDevMode && routerInstance) {
    console.log("[Router] HMR: Cleaning up old router instance");
    routerInstance.cleanup();
    routerInstance = null;
    isRouterInitialized = false;
  }
  let rootSelector = "#app-root";
  let currentPath = null;
  let isDestroyed = false;
  let listenerCount = 0;
  let renderTimeout = null;
  let lastNavigationTime = 0;
  const NAVIGATION_RATE_LIMIT = 100;
  const listeners = [];
  if (!window[PROPS_NAMESPACE]) {
    window[PROPS_NAMESPACE] = {};
  }
  if (isDevMode && window.__fynixPropsCache) {
    window.__fynixPropsCache.clear();
  }
  const propsCache = window.__fynixPropsCache || /* @__PURE__ */ new Map();
  window.__fynixPropsCache = propsCache;
  const modules = tryGlobPaths();
  const routes = {};
  const dynamicRoutes = [];
  for (const [filePath, mod] of Object.entries(modules)) {
    const routePath = filePathToRoute(filePath);
    let component = void 0;
    if (mod && typeof mod === "object") {
      if ("default" in mod && mod.default) {
        component = mod.default;
      } else {
        const keys = Object.keys(mod);
        const firstKey = keys.length > 0 ? keys[0] : void 0;
        if (firstKey !== void 0 && typeof firstKey === "string" && typeof mod[firstKey] !== "undefined") {
          component = mod[firstKey];
        } else {
          const values = Object.values(mod).filter(Boolean);
          if (values.length > 0) {
            component = values[0];
          }
        }
      }
    }
    if (!component || typeof routePath !== "string")
      continue;
    const hasDynamic = /:[^/]+/.test(routePath);
    if (hasDynamic) {
      dynamicRoutes.push({
        pattern: routePath,
        regex: new RegExp("^" + routePath.replace(/:[^/]+/g, "([^/]+)") + "$"),
        component,
        params: [...routePath.matchAll(/:([^/]+)/g)].map((m) => m[1]).filter((p) => typeof p === "string")
      });
    } else {
      routes[routePath] = component;
    }
  }
  async function renderRouteImmediate() {
    if (isDestroyed)
      return;
    const path = normalizePath(window.location.pathname);
    let Page = routes[path];
    let params = {};
    let routeProps = {};
    const enterpriseMatch = enterpriseRouter.matchRoute(path);
    if (enterpriseMatch) {
      const preloadedComponent = enterpriseRouter.getPreloadedComponent(path);
      if (preloadedComponent) {
        Page = preloadedComponent;
      } else {
        Page = enterpriseMatch.component;
      }
      params = enterpriseMatch.params;
    }
    if (!Page) {
      const match = matchDynamicRoute(path, dynamicRoutes);
      if (match) {
        Page = match.component;
        params = match.params;
      }
    }
    const root = document.querySelector(rootSelector);
    if (!root) {
      console.error("[Router] Root element not found:", rootSelector);
      return;
    }
    if (!Page) {
      root.innerHTML = "";
      const container = document.createElement("div");
      container.style.cssText = "padding: 2rem; text-align: center; font-family: system-ui, sans-serif;";
      const heading = document.createElement("h2");
      heading.textContent = "404 Not Found";
      heading.style.cssText = "color: #dc2626; margin-bottom: 1rem;";
      const pathInfo = document.createElement("p");
      const safePath = escapeHTML(sanitizeContent(path));
      pathInfo.textContent = `Path: ${safePath}`;
      pathInfo.style.cssText = "color: #6b7280; margin-bottom: 2rem;";
      const backButton = document.createElement("button");
      backButton.textContent = "Go Back";
      backButton.style.cssText = "padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 0.25rem; cursor: pointer;";
      backButton.onclick = () => window.history.back();
      container.appendChild(heading);
      container.appendChild(pathInfo);
      container.appendChild(backButton);
      root.appendChild(container);
      updateMetaTags({ title: "404 - Page Not Found" });
      ["/", "/home", "/about"].forEach((commonPath) => {
        enterpriseRouter.preloadRoute(commonPath).catch(console.warn);
      });
      return;
    }
    const state = window.history.state || {};
    let passedProps = {};
    if (state.__fynixCacheKey && propsCache.has(state.__fynixCacheKey)) {
      passedProps = propsCache.get(state.__fynixCacheKey);
    } else if (state.serializedProps) {
      passedProps = deserializeProps(state.serializedProps);
    }
    if (Page.props) {
      routeProps = typeof Page.props === "function" ? Page.props() : Page.props;
    }
    if (Page.meta) {
      const meta = typeof Page.meta === "function" ? Page.meta(params) : Page.meta;
      updateMetaTags(meta);
    }
    const unsafeProps = {
      ...routeProps,
      ...passedProps,
      params
    };
    const safeProps = sanitizeProps(unsafeProps);
    window.__lastRouteProps = safeProps;
    try {
      mount(Page, rootSelector, safeProps);
    } catch (err) {
      console.error("[Router] Mount failed:", err);
      root.innerHTML = "";
      const errorDiv = document.createElement("pre");
      errorDiv.style.color = "red";
      errorDiv.textContent = "Mount Error occurred";
      root.appendChild(errorDiv);
    }
    currentPath = path;
  }
  function renderRoute() {
    if (isDestroyed)
      return;
    if (renderTimeout) {
      clearTimeout(renderTimeout);
    }
    renderTimeout = setTimeout(async () => {
      await renderRouteImmediate();
      renderTimeout = null;
    }, RENDER_DEBOUNCE);
  }
  function navigate(path, props = {}) {
    if (isDestroyed)
      return;
    const now = Date.now();
    if (now - lastNavigationTime < NAVIGATION_RATE_LIMIT) {
      console.warn("[Router] Security: Navigation rate limited");
      return;
    }
    lastNavigationTime = now;
    const normalizedPath = normalizePath(path);
    if (!isValidURL(window.location.origin + normalizedPath)) {
      console.error("[Router] Invalid navigation URL");
      return;
    }
    if (normalizedPath === currentPath)
      return;
    enterpriseRouter.preloadRoute(normalizedPath).catch(console.warn);
    const sanitizedProps = sanitizeProps(props);
    const cacheKey = generateCacheKey();
    addToCache(propsCache, cacheKey, sanitizedProps);
    try {
      window.history.pushState({ __fynixCacheKey: cacheKey }, "", normalizedPath);
      renderRoute();
    } catch (err) {
      console.error("[Router] Navigation failed:", err);
    }
  }
  function replace(path, props = {}) {
    if (isDestroyed)
      return;
    const now = Date.now();
    if (now - lastNavigationTime < NAVIGATION_RATE_LIMIT) {
      console.warn("[Router] Security: Replace rate limited");
      return;
    }
    lastNavigationTime = now;
    const normalizedPath = normalizePath(path);
    if (!isValidURL(window.location.origin + normalizedPath)) {
      console.error("[Router] Invalid replace URL");
      return;
    }
    const sanitizedProps = sanitizeProps(props);
    const cacheKey = generateCacheKey();
    addToCache(propsCache, cacheKey, sanitizedProps);
    try {
      window.history.replaceState({ __fynixCacheKey: cacheKey }, "", normalizedPath);
      renderRoute();
    } catch (err) {
      console.error("[Router] Replace failed:", err);
    }
  }
  function back() {
    if (isDestroyed)
      return;
    try {
      window.history.back();
    } catch (err) {
      console.error("[Router] Back navigation failed:", err);
    }
  }
  const clickHandler = (e) => {
    if (isDestroyed)
      return;
    const target = e.target;
    const link = target.closest("a[data-fynix-link]");
    if (!link)
      return;
    const href = link.getAttribute("href");
    if (!href) {
      console.warn("[Router] Missing href attribute");
      return;
    }
    if (isExternal(href)) {
      return;
    }
    const fullUrl = new URL(link.href, window.location.origin).href;
    if (!isValidURL(fullUrl)) {
      console.warn("[Router] Invalid link href");
      return;
    }
    e.preventDefault();
    const path = normalizePath(new URL(link.href, window.location.origin).pathname);
    if (path === currentPath)
      return;
    let props = {};
    const propsKey = link.getAttribute("data-props-key");
    if (propsKey && typeof propsKey === "string" && !propsKey.startsWith("__")) {
      if (window[PROPS_NAMESPACE]?.[propsKey]) {
        props = window[PROPS_NAMESPACE][propsKey];
      }
    }
    const serializableProps = {};
    for (const [k, v] of Object.entries(props)) {
      if (typeof k !== "string" || k.startsWith("__"))
        continue;
      serializableProps[k] = v && (v._isNixState || v._isRestState) ? v.value : v;
    }
    const cacheKey = generateCacheKey();
    addToCache(propsCache, cacheKey, serializableProps);
    try {
      window.history.pushState({ __fynixCacheKey: cacheKey, serializedProps: serializableProps }, "", path);
      renderRoute();
    } catch (err) {
      console.error("[Router] Link navigation failed:", err);
    }
  };
  if (listenerCount < MAX_LISTENERS && !isRouterInitialized) {
    document.addEventListener("click", clickHandler);
    listeners.push({
      element: document,
      event: "click",
      handler: clickHandler
    });
    listenerCount++;
    window.addEventListener("popstate", renderRoute);
    listeners.push({
      element: window,
      event: "popstate",
      handler: renderRoute
    });
    listenerCount++;
  }
  function mountRouter(selector = "#app-root") {
    if (isDestroyed) {
      console.error("[Router] Cannot mount destroyed router");
      return;
    }
    if (typeof selector !== "string" || selector.length === 0) {
      console.error("[Router] Invalid selector");
      return;
    }
    rootSelector = selector;
    renderRoute();
    isRouterInitialized = true;
  }
  function cleanup() {
    if (renderTimeout) {
      clearTimeout(renderTimeout);
      renderTimeout = null;
    }
    isDestroyed = true;
    enterpriseRouter.clearCache();
    layoutRouter.cleanup();
    listeners.forEach(({ element, event, handler }) => {
      try {
        element.removeEventListener(event, handler);
      } catch (e) {
        console.error("[Router] Cleanup error:", e);
      }
    });
    listeners.length = 0;
    listenerCount = 0;
    propsCache.forEach((props) => {
      if (props && typeof props === "object") {
        Object.values(props).forEach((val) => {
          if (val && typeof val === "object" && "cleanup" in val) {
            try {
              val.cleanup();
            } catch (e) {
            }
          }
        });
      }
    });
    propsCache.clear();
    if (window[PROPS_NAMESPACE]) {
      const ns = window[PROPS_NAMESPACE];
      if (ns && typeof ns === "object") {
        Object.keys(ns).forEach((key) => {
          delete ns[key];
        });
      }
      delete window[PROPS_NAMESPACE];
    }
    if (window.__lastRouteProps) {
      delete window.__lastRouteProps;
    }
    isRouterInitialized = false;
    routerInstance = null;
    console.log("[Router] Cleanup complete");
  }
  if (import.meta.hot) {
    import.meta.hot.accept(() => {
      console.log("[Router] HMR detected, re-rendering route...");
      renderRoute();
    });
    import.meta.hot.dispose(() => {
      console.log("[Router] HMR dispose, cleaning up...");
      cleanup();
      routerInstance = null;
      isRouterInitialized = false;
    });
  }
  const router = {
    mountRouter,
    navigate,
    replace,
    back,
    cleanup,
    routes,
    dynamicRoutes,
    preloadRoute: enterpriseRouter.preloadRoute.bind(enterpriseRouter),
    clearCache: () => {
      enterpriseRouter.clearCache();
      layoutRouter.cleanup();
    },
    enableNestedRouting: (nestedRoutes) => {
      router.nestedRoutes = nestedRoutes;
      console.log("[Router] Nested routing enabled with", nestedRoutes.length, "routes");
    }
  };
  routerInstance = router;
  return router;
}
var router_default = createFynix;
function setLinkProps(key, props) {
  if (typeof key !== "string" || key.startsWith("__")) {
    console.error("[Router] Invalid props key");
    return;
  }
  if (!props || typeof props !== "object") {
    console.error("[Router] Invalid props object");
    return;
  }
  if (!window[PROPS_NAMESPACE]) {
    window[PROPS_NAMESPACE] = {};
  }
  if (Object.keys(window[PROPS_NAMESPACE]).length >= MAX_CACHE_SIZE) {
    console.warn("[Router] Props storage limit reached");
    return;
  }
  window[PROPS_NAMESPACE][key] = props;
}
function clearLinkProps(key) {
  if (typeof key !== "string")
    return;
  if (window[PROPS_NAMESPACE]?.[key]) {
    const props = window[PROPS_NAMESPACE][key];
    if (props && typeof props === "object") {
      Object.values(props).forEach((val) => {
        if (val && typeof val === "object" && "cleanup" in val) {
          try {
            val.cleanup();
          } catch (e) {
          }
        }
      });
    }
    delete window[PROPS_NAMESPACE][key];
  }
}

// node_modules/fynixui/dist/runtime.js
var SimplePriorityQueue = class {
  constructor() {
    this.items = [];
    this.priorityOrder = {
      immediate: 0,
      high: 1,
      normal: 2,
      low: 3,
      idle: 4
    };
  }
  push(item, priority) {
    this.items.push({ item, priority });
    this.items.sort((a, b) => this.priorityOrder[a.priority] - this.priorityOrder[b.priority]);
  }
  pop() {
    return this.items.shift()?.item;
  }
  peek() {
    return this.items[0]?.item;
  }
  size() {
    return this.items.length;
  }
  isEmpty() {
    return this.items.length === 0;
  }
};
var FynixScheduler = class {
  constructor() {
    this.updateQueue = new SimplePriorityQueue();
    this.batchedUpdates = /* @__PURE__ */ new Set();
    this.isScheduled = false;
    this.isWorking = false;
    this.currentPriority = "normal";
    this.updateIdCounter = 0;
  }
  schedule(update, priority = "normal") {
    update.id = `update_${this.updateIdCounter++}`;
    update.priority = priority;
    update.timestamp = performance.now();
    if (priority === "immediate") {
      this.flushUpdate(update);
    } else {
      this.updateQueue.push(update, priority);
      this.scheduleWork();
    }
  }
  batchUpdates(updates) {
    updates.forEach((update) => this.batchedUpdates.add(update));
    this.scheduleWork();
  }
  timeSlice(deadline) {
    const startTime = performance.now();
    const previousPriority = this.currentPriority;
    while (!this.updateQueue.isEmpty() && performance.now() - startTime < deadline) {
      const update = this.updateQueue.pop();
      if (update) {
        if (this.shouldYield() && update.priority !== "immediate") {
          this.updateQueue.push(update, update.priority);
          break;
        }
        this.flushUpdate(update);
      }
    }
    this.currentPriority = previousPriority;
    return this.updateQueue.isEmpty();
  }
  flush() {
    if (this.isWorking)
      return;
    this.isWorking = true;
    try {
      while (!this.updateQueue.isEmpty()) {
        const update = this.updateQueue.peek();
        if (update && update.priority === "immediate") {
          this.flushUpdate(this.updateQueue.pop());
        } else {
          break;
        }
      }
      this.batchedUpdates.forEach((update) => this.flushUpdate(update));
      this.batchedUpdates.clear();
    } finally {
      this.isWorking = false;
      this.isScheduled = false;
    }
  }
  flushUpdate(update) {
    const previousPriority = this.currentPriority;
    this.currentPriority = update.priority;
    try {
      update.callback();
    } catch (error) {
      console.error("[FynixScheduler] Update error:", error);
      showErrorOverlay(error);
    } finally {
      this.currentPriority = previousPriority;
    }
  }
  scheduleWork() {
    if (this.isScheduled)
      return;
    this.isScheduled = true;
    const nextUpdate = this.updateQueue.peek();
    if (nextUpdate) {
      if (nextUpdate.priority === "high") {
        requestAnimationFrame(() => this.workLoop(16.67));
      } else {
        if ("requestIdleCallback" in window) {
          requestIdleCallback((deadline) => {
            this.workLoop(deadline.timeRemaining());
          });
        } else {
          setTimeout(() => this.workLoop(5), 0);
        }
      }
    }
  }
  workLoop(deadline) {
    const hasMoreWork = !this.timeSlice(deadline);
    if (hasMoreWork) {
      this.isScheduled = false;
      this.scheduleWork();
    } else {
      this.flush();
    }
  }
  getCurrentPriority() {
    return this.currentPriority;
  }
  shouldYield() {
    const nextUpdate = this.updateQueue.peek();
    if (!nextUpdate)
      return false;
    const currentPriorityLevel = this.getPriorityLevel(this.currentPriority);
    const nextPriorityLevel = this.getPriorityLevel(nextUpdate.priority);
    return nextPriorityLevel < currentPriorityLevel;
  }
  getPriorityLevel(priority) {
    const levels = { immediate: 0, high: 1, normal: 2, low: 3, idle: 4 };
    return levels[priority];
  }
};
var scheduler = new FynixScheduler();
var FiberRenderer = class {
  constructor() {
    this.workInProgressRoot = null;
    this.nextUnitOfWork = null;
    this.currentRoot = null;
    this.deletions = [];
  }
  scheduleWork(fiber) {
    this.workInProgressRoot = {
      ...fiber,
      alternate: this.currentRoot
    };
    this.nextUnitOfWork = this.workInProgressRoot;
    this.deletions = [];
    scheduler.schedule({
      id: "",
      type: "layout",
      priority: "high",
      callback: () => this.workLoop(5),
      timestamp: performance.now()
    }, "high");
  }
  workLoop(deadline) {
    const startTime = performance.now();
    while (this.nextUnitOfWork && performance.now() - startTime < deadline) {
      this.nextUnitOfWork = this.performUnitOfWork(this.nextUnitOfWork);
    }
    if (!this.nextUnitOfWork && this.workInProgressRoot) {
      this.commitRoot();
    } else if (this.nextUnitOfWork) {
      scheduler.schedule({
        id: "",
        type: "layout",
        priority: "normal",
        callback: () => this.workLoop(5),
        timestamp: performance.now()
      }, "normal");
    }
  }
  performUnitOfWork(fiber) {
    this.reconcileChildren(fiber, fiber.props?.children || []);
    if (fiber.child) {
      return fiber.child;
    }
    let nextFiber = fiber;
    while (nextFiber) {
      if (nextFiber.sibling) {
        return nextFiber.sibling;
      }
      nextFiber = nextFiber.parent;
    }
    return null;
  }
  reconcileChildren(wipFiber, elements) {
    let index = 0;
    let oldFiber = wipFiber.alternate?.child;
    let prevSibling = null;
    while (index < elements.length || oldFiber != null) {
      const element = elements[index];
      let newFiber = null;
      const sameType = oldFiber && element && element.type === oldFiber.type;
      if (sameType && oldFiber) {
        newFiber = {
          type: oldFiber.type,
          props: element.props,
          key: element.key,
          _domNode: oldFiber._domNode,
          parent: wipFiber,
          alternate: oldFiber,
          effectTag: "UPDATE",
          updatePriority: "normal",
          child: null,
          sibling: null,
          _rendered: null
        };
      }
      if (element && !sameType) {
        newFiber = {
          type: element.type,
          props: element.props,
          key: element.key,
          _domNode: null,
          parent: wipFiber,
          alternate: null,
          effectTag: "PLACEMENT",
          updatePriority: "normal",
          child: null,
          sibling: null,
          _rendered: null
        };
      }
      if (oldFiber && !sameType) {
        oldFiber.effectTag = "DELETION";
        this.deletions.push(oldFiber);
      }
      if (oldFiber) {
        oldFiber = oldFiber.sibling;
      }
      if (index === 0) {
        wipFiber.child = newFiber;
      } else if (newFiber && prevSibling) {
        prevSibling.sibling = newFiber;
      }
      prevSibling = newFiber;
      index++;
    }
  }
  commitRoot() {
    this.deletions.forEach((fiber) => this.commitWork(fiber));
    if (this.workInProgressRoot?.child) {
      this.commitWork(this.workInProgressRoot.child);
    }
    this.currentRoot = this.workInProgressRoot;
    this.workInProgressRoot = null;
  }
  commitWork(fiber) {
    if (!fiber)
      return;
    let domParentFiber = fiber.parent;
    while (!domParentFiber?._domNode) {
      domParentFiber = domParentFiber?.parent || null;
    }
    const domParent = domParentFiber?._domNode;
    if (fiber.effectTag === "PLACEMENT" && fiber._domNode && domParent) {
      domParent.appendChild(fiber._domNode);
    } else if (fiber.effectTag === "UPDATE" && fiber._domNode) {
      this.updateDom(fiber._domNode, fiber.alternate?.props || {}, fiber.props);
    } else if (fiber.effectTag === "DELETION" && domParent) {
      this.commitDeletion(fiber, domParent);
    }
    this.commitWork(fiber.child);
    this.commitWork(fiber.sibling);
  }
  commitDeletion(fiber, domParent) {
    if (fiber._domNode) {
      domParent.removeChild(fiber._domNode);
    } else if (fiber.child) {
      this.commitDeletion(fiber.child, domParent);
    }
  }
  updateDom(dom, prevProps, nextProps) {
    Object.keys(prevProps).filter((key) => key !== "children" && !(key in nextProps)).forEach((name) => {
      if (name.startsWith("on")) {
        const eventType = name.toLowerCase().substring(2);
        dom.removeEventListener(eventType, prevProps[name]);
      } else {
        dom[name] = "";
      }
    });
    Object.keys(nextProps).filter((key) => key !== "children").forEach((name) => {
      if (prevProps[name] !== nextProps[name]) {
        if (name.startsWith("on")) {
          const eventType = name.toLowerCase().substring(2);
          dom.addEventListener(eventType, nextProps[name]);
        } else {
          dom[name] = nextProps[name];
        }
      }
    });
  }
};
var fiberRenderer = new FiberRenderer();
function useFiberRenderer() {
  return fiberRenderer;
}
var HierarchicalStore = class {
  constructor() {
    this.root = /* @__PURE__ */ new Map();
    this.selectorCache = /* @__PURE__ */ new Map();
    this.stateSnapshot = {};
  }
  select(selector) {
    const selectorKey = selector.toString();
    if (this.selectorCache.has(selectorKey)) {
      return this.selectorCache.get(selectorKey);
    }
    const result = selector(this.getState());
    this.selectorCache.set(selectorKey, result);
    return result;
  }
  optimisticUpdate(path, update, rollback) {
    const original = this.get(path);
    this.set(path, update);
    return {
      commit: () => this.clearRollback(path),
      rollback: () => {
        this.set(path, original);
        rollback?.();
      }
    };
  }
  getState() {
    return this.stateSnapshot;
  }
  get(path) {
    return this.root.get(path)?.value;
  }
  set(path, value) {
    const node = this.root.get(path);
    if (node) {
      node.value = value;
      this.stateSnapshot = { ...this.stateSnapshot, [path]: value };
      this.invalidateSelectors();
    }
  }
  clearRollback(path) {
    console.log(`[HierarchicalStore] Optimistic update committed for path: ${path}`);
  }
  invalidateSelectors() {
    this.selectorCache.clear();
  }
};
var hierarchicalStore = new HierarchicalStore();
function useHierarchicalStore() {
  return hierarchicalStore;
}
var TEXT = /* @__PURE__ */ Symbol("text");
var Fragment = /* @__PURE__ */ Symbol("Fragment");
var BOOLEAN_ATTRS = /* @__PURE__ */ new Set([
  "checked",
  "selected",
  "disabled",
  "readonly",
  "multiple",
  "autoplay",
  "controls",
  "loop",
  "muted",
  "open",
  "required",
  "reversed",
  "scoped",
  "seamless",
  "autofocus",
  "novalidate",
  "formnovalidate"
]);
var DOM_PROPERTIES = /* @__PURE__ */ new Set([
  "value",
  "checked",
  "selected",
  "selectedIndex",
  "innerHTML",
  "textContent",
  "innerText"
]);
var DANGEROUS_HTML_PROPS = /* @__PURE__ */ new Set([
  "innerHTML",
  "outerHTML",
  "insertAdjacentHTML",
  "srcdoc"
]);
var DANGEROUS_PROTOCOLS = /* @__PURE__ */ new Set([
  "javascript:",
  "data:",
  "vbscript:",
  "file:",
  "about:"
]);
var SAFE_PROTOCOLS = /* @__PURE__ */ new Set([
  "http:",
  "https:",
  "ftp:",
  "ftps:",
  "mailto:",
  "tel:",
  "#",
  "/",
  "./",
  "../"
]);
function createTextVNode(text) {
  if (text == null || text === false) {
    return { type: TEXT, props: { nodeValue: "" }, key: null };
  }
  if (text && typeof text === "object" && text._isNixState) {
    const vnode = {
      type: TEXT,
      props: { nodeValue: String(text.value) },
      key: null,
      _state: text,
      _cleanup: null
    };
    vnode._cleanup = text.subscribe(() => {
      if (vnode._domNode) {
        vnode._domNode.nodeValue = String(text.value);
      }
    });
    return vnode;
  }
  return { type: TEXT, props: { nodeValue: String(text) }, key: null };
}
function h(type, props = null, ...children) {
  const normalizedProps = props === null || typeof props !== "object" || Array.isArray(props) ? {} : props;
  const flatChildren = [];
  for (const c of children.flat(Infinity)) {
    if (c == null || c === false)
      continue;
    if (c && typeof c === "object" && "_isNixState" in c) {
      flatChildren.push(createTextVNode(c));
    } else if (typeof c === "string" || typeof c === "number") {
      flatChildren.push(createTextVNode(c));
    } else if (c && typeof c === "object" && "type" in c) {
      if (c.type === Fragment) {
        const fragmentChildren = (c.props.children || []).filter((x) => x != null && x !== false);
        flatChildren.push(...fragmentChildren);
      } else {
        flatChildren.push(c);
      }
    } else if (typeof c === "function") {
      flatChildren.push(c);
    } else {
      flatChildren.push(createTextVNode(String(c)));
    }
  }
  const key = normalizedProps.key ?? null;
  if (key !== void 0)
    delete normalizedProps.key;
  if (type === Fragment) {
    return { type: Fragment, props: { children: flatChildren }, key };
  }
  return {
    type,
    props: { ...normalizedProps, children: flatChildren },
    key
  };
}
h.Fragment = ({ children }) => children || [];
var Fynix = h;
Fynix.Fragment = h.Fragment;
var componentInstances = /* @__PURE__ */ new WeakMap();
var rootRenderFn = null;
var pendingRerenders = /* @__PURE__ */ new WeakSet();
function beginComponent(vnode) {
  let ctx = componentInstances.get(vnode);
  if (!ctx) {
    ctx = {
      hooks: [],
      hookIndex: 0,
      effects: [],
      cleanups: [],
      _vnode: vnode,
      _accessedStates: /* @__PURE__ */ new Set(),
      _subscriptions: /* @__PURE__ */ new Set(),
      _subscriptionCleanups: [],
      version: 0,
      rerender: null,
      Component: vnode.type,
      _isMounted: false,
      _isRerendering: false
    };
    componentInstances.set(vnode, ctx);
  }
  ctx.hookIndex = 0;
  ctx._accessedStates.clear();
  setActiveContext(ctx);
  ctx.version++;
  return ctx;
}
function endComponent() {
  const ctx = activeContext;
  if (!ctx)
    return;
  ctx._accessedStates.forEach((state) => {
    if (!ctx._subscriptions.has(state)) {
      if (!ctx.rerender) {
        let rerenderTimeout = null;
        ctx.rerender = function rerender() {
          if (ctx._isRerendering || pendingRerenders.has(ctx)) {
            return;
          }
          if (rerenderTimeout) {
            clearTimeout(rerenderTimeout);
          }
          rerenderTimeout = setTimeout(async () => {
            if (ctx._isRerendering || !ctx._isMounted)
              return;
            ctx._isRerendering = true;
            pendingRerenders.add(ctx);
            try {
              removeErrorOverlay();
              const vnode = ctx._vnode;
              const oldRendered = vnode._rendered;
              beginComponent(vnode);
              const result = ctx.Component(vnode.props);
              const newRendered = result instanceof Promise ? await result : result;
              endComponent();
              vnode._rendered = newRendered;
              const domNode = vnode._domNode;
              if (domNode && domNode.parentNode) {
                await patch(domNode.parentNode, newRendered, oldRendered);
                if (newRendered && typeof newRendered === "object") {
                  vnode._domNode = newRendered._domNode;
                }
                ctx._isRerendering = false;
                pendingRerenders.delete(ctx);
              } else if (rootRenderFn) {
                await rootRenderFn();
                ctx._isRerendering = false;
                pendingRerenders.delete(ctx);
              } else {
                ctx._isRerendering = false;
                pendingRerenders.delete(ctx);
              }
            } catch (err) {
              console.error("[Fynix] Component rerender error:", err);
              showErrorOverlay(err);
              ctx._isRerendering = false;
              pendingRerenders.delete(ctx);
            }
            rerenderTimeout = null;
          }, 0);
        };
      }
      const unsub = state.subscribe(() => {
        if (ctx.rerender && ctx._isMounted) {
          if (typeof queueMicrotask === "function") {
            queueMicrotask(() => ctx.rerender());
          } else {
            setTimeout(ctx.rerender, 0);
          }
        }
      });
      ctx._subscriptions.add(state);
      ctx._subscriptionCleanups.push(unsub);
    }
  });
  setActiveContext(null);
}
function renderComponent(Component, props = {}) {
  const vnode = { type: Component, props, key: null };
  const ctx = beginComponent(vnode);
  ctx.Component = Component;
  if (!ctx.rerender) {
    let rerenderTimeout = null;
    ctx.rerender = () => {
      if (ctx._isRerendering || pendingRerenders.has(ctx))
        return;
      if (rerenderTimeout) {
        clearTimeout(rerenderTimeout);
      }
      rerenderTimeout = setTimeout(async () => {
        if (ctx._isRerendering || !ctx._isMounted)
          return;
        ctx._isRerendering = true;
        pendingRerenders.add(ctx);
        try {
          removeErrorOverlay();
          const vnode2 = ctx._vnode;
          const oldRendered = vnode2._rendered;
          beginComponent(vnode2);
          const result = ctx.Component(vnode2.props);
          const newRendered = result instanceof Promise ? await result : result;
          endComponent();
          vnode2._rendered = newRendered;
          const domNode = vnode2._domNode;
          if (domNode && domNode.parentNode) {
            await patch(domNode.parentNode, newRendered, oldRendered);
            if (newRendered && typeof newRendered === "object") {
              vnode2._domNode = newRendered._domNode;
            }
            ctx._isRerendering = false;
            pendingRerenders.delete(ctx);
          } else if (rootRenderFn) {
            await rootRenderFn();
            ctx._isRerendering = false;
            pendingRerenders.delete(ctx);
          } else {
            ctx._isRerendering = false;
            pendingRerenders.delete(ctx);
          }
        } catch (err) {
          console.error("[Fynix] Component rerender error:", err);
          showErrorOverlay(err);
          ctx._isRerendering = false;
          pendingRerenders.delete(ctx);
        }
        rerenderTimeout = null;
      }, 0);
    };
  }
  try {
    removeErrorOverlay();
    const result = Component(props);
    if (result instanceof Promise) {
      const placeholderVNode = h("div", null, "Loading...");
      ctx._vnode = vnode;
      vnode._rendered = placeholderVNode;
      ctx._isMounted = true;
      result.then((resolvedVNode) => {
        vnode._rendered = resolvedVNode;
        if (ctx.rerender) {
          ctx.rerender();
        }
      }).catch((err) => {
        console.error("[Fynix] Async component error:", err);
        showErrorOverlay(err);
      });
      return placeholderVNode;
    }
    ctx._vnode = vnode;
    vnode._rendered = result;
    ctx._isMounted = true;
    return result;
  } catch (err) {
    console.error("[Fynix] Component render error:", err);
    showErrorOverlay(err);
    return h("div", { style: "color:red" }, `Error: ${sanitizeErrorMessage(err)}`);
  } finally {
    endComponent();
  }
}
var delegatedEvents = /* @__PURE__ */ new Map();
var eventIdCounter = 1;
function ensureDelegated(eventType) {
  if (delegatedEvents.has(eventType))
    return;
  delegatedEvents.set(eventType, /* @__PURE__ */ new Map());
  document.addEventListener(eventType, (e) => {
    let cur = e.target;
    while (cur && cur !== document) {
      if (cur.nodeType !== 1)
        break;
      const el = cur;
      const eid = el._rest_eid;
      const map = delegatedEvents.get(eventType);
      if (eid != null && map?.has(eid)) {
        map.get(eid)(e);
        return;
      }
      cur = cur.parentElement;
    }
  });
}
function registerDelegatedHandler(el, eventName, fn) {
  if (!fn || el.nodeType !== 1)
    return;
  const anyEl = el;
  const eid = anyEl._rest_eid ?? (anyEl._rest_eid = ++eventIdCounter);
  ensureDelegated(eventName);
  delegatedEvents.get(eventName).set(eid, (e) => {
    try {
      fn.call(el, e);
    } catch (err) {
      console.error("[Fynix] Event handler error:", err);
      showErrorOverlay(err);
    }
  });
}
function sanitizeText(text) {
  if (typeof text !== "string")
    return String(text);
  return text.replace(/[<>"'&]/g, (match) => {
    const entityMap = {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "&": "&amp;"
    };
    return entityMap[match] || match;
  }).replace(/javascript:/gi, "blocked:").replace(/data:.*?base64/gi, "blocked:");
}
function sanitizeAttributeValue(value) {
  if (typeof value !== "string")
    return String(value);
  return value.replace(/["'<>]/g, (match) => {
    const entityMap = {
      '"': "&quot;",
      "'": "&#x27;",
      "<": "&lt;",
      ">": "&gt;"
    };
    return entityMap[match] || match;
  }).replace(/javascript:/gi, "blocked:").replace(/on\w+=/gi, "blocked=");
}
function sanitizeErrorMessage(error) {
  if (!error)
    return "Unknown error";
  const message = error.message || error.toString() || "Unknown error";
  return sanitizeText(String(message)).slice(0, 200);
}
function setProperty(el, key, value) {
  const k = key.toLowerCase();
  if (key === "r-class" || key === "rc") {
    if (typeof value === "string") {
      el.setAttribute("class", value);
    } else if (value && (value._isNixState || value._isRestState)) {
      el.setAttribute("class", value.value);
      const anyEl = el;
      if (!anyEl._fynixCleanups)
        anyEl._fynixCleanups = [];
      const unsub = value.subscribe(() => el.setAttribute("class", value.value));
      anyEl._fynixCleanups.push(unsub);
    }
    return;
  }
  if (key.startsWith("r-")) {
    registerDelegatedHandler(el, key.slice(2).toLowerCase(), value);
    return;
  }
  if (key === "style" && typeof value === "object") {
    Object.assign(el.style, value);
    return;
  }
  if (DANGEROUS_HTML_PROPS.has(key)) {
    console.error(`[Fynix] Security: ${key} is blocked for security reasons. Use textContent or children instead.`);
    return;
  }
  if ((key === "href" || key === "src" || key === "action" || key === "formaction") && typeof value === "string") {
    const normalizedValue = value.trim().toLowerCase();
    for (const protocol of DANGEROUS_PROTOCOLS) {
      if (normalizedValue.startsWith(protocol)) {
        console.error(`[Fynix] Security: ${protocol} protocol blocked in ${key}`);
        return;
      }
    }
    if (normalizedValue.includes(":")) {
      const protocol = normalizedValue.split(":")[0] + ":";
      if (!SAFE_PROTOCOLS.has(protocol) && !SAFE_PROTOCOLS.has(normalizedValue.charAt(0))) {
        console.error(`[Fynix] Security: Protocol '${protocol}' not in safe list for ${key}`);
        return;
      }
    }
    if (normalizedValue.startsWith("data:")) {
      if (normalizedValue.includes("javascript") || normalizedValue.includes("<script")) {
        console.error(`[Fynix] Security: Suspicious data: URL blocked in ${key}`);
        return;
      }
    }
  }
  if (key.toLowerCase().startsWith("on") && key !== "open") {
    console.error(`[Fynix] Security: Inline event handler '${key}' blocked. Use r-${key.slice(2)} instead.`);
    return;
  }
  if (BOOLEAN_ATTRS.has(k)) {
    if (value) {
      el.setAttribute(k, "");
      el[k] = true;
    } else {
      el.removeAttribute(k);
      el[k] = false;
    }
    return;
  }
  if (DOM_PROPERTIES.has(key) && !DANGEROUS_HTML_PROPS.has(key)) {
    if (key === "textContent" || key === "innerText") {
      el[key] = sanitizeText(value ?? "");
    } else {
      el[key] = value ?? "";
    }
    return;
  }
  if (key.startsWith("data-") || key.startsWith("aria-")) {
    if (value != null && value !== false) {
      el.setAttribute(key, sanitizeAttributeValue(String(value)));
    } else {
      el.removeAttribute(key);
    }
    return;
  }
  if (value != null && value !== false) {
    el.setAttribute(key, value);
  }
}
async function createDom(vnode, existing = null) {
  if (vnode == null) {
    return document.createTextNode("");
  }
  if (typeof vnode === "string" || typeof vnode === "number") {
    return document.createTextNode(String(vnode));
  }
  if (vnode instanceof Promise) {
    const placeholder = document.createTextNode("Loading...");
    vnode.then(async (resolved) => {
      try {
        const dom = await createDom(resolved);
        if (placeholder.parentNode) {
          placeholder.replaceWith(dom);
        }
      } catch (err) {
        console.error("[Fynix] Async component error:", err);
        if (placeholder.parentNode) {
          placeholder.textContent = "Error loading component";
        }
      }
    }).catch((err) => {
      console.error("[Fynix] Async component promise error:", err);
      if (placeholder.parentNode) {
        placeholder.textContent = "Error loading async component";
      }
    });
    return placeholder;
  }
  const vnodeObj = vnode;
  if (vnodeObj.type === TEXT) {
    const textNode = existing || document.createTextNode(vnodeObj.props.nodeValue ?? "");
    vnodeObj._domNode = textNode;
    return textNode;
  }
  if (vnodeObj.type === Fragment) {
    const frag = document.createDocumentFragment();
    for (const child of vnodeObj.props?.children || []) {
      frag.appendChild(await createDom(child));
    }
    vnodeObj._domNode = frag;
    return frag;
  }
  if (typeof vnodeObj.type === "function") {
    const rendered = await renderMaybeAsyncComponent(vnodeObj.type, vnodeObj.props, vnodeObj);
    vnodeObj._rendered = rendered;
    const dom = await createDom(rendered);
    vnodeObj._domNode = dom;
    return dom;
  }
  const el = existing || document.createElement(vnodeObj.type);
  for (const [k, v] of Object.entries(vnodeObj.props || {})) {
    if (k !== "children") {
      setProperty(el, k, v);
    }
  }
  for (const child of vnodeObj.props?.children || []) {
    el.appendChild(await createDom(child));
  }
  vnodeObj._domNode = el;
  return el;
}
async function renderMaybeAsyncComponent(Component, props, vnode) {
  const ctx = beginComponent(vnode);
  removeErrorOverlay();
  try {
    const result = await Component(props);
    ctx._vnode = vnode;
    vnode._rendered = result;
    ctx._isMounted = true;
    endComponent();
    return result ?? null;
  } catch (err) {
    console.error("[Fynix] async render error:", err);
    showErrorOverlay(err);
    ctx._isMounted = false;
    endComponent();
    return h("div", { style: "color:red" }, `Error: ${sanitizeErrorMessage(err)}`);
  }
}
async function patch(parent, newVNode, oldVNode) {
  if (!(parent instanceof Node)) {
    console.error("[Fynix] patch() expects a DOM Node, got:", typeof parent, parent);
    return;
  }
  if (!newVNode && !oldVNode)
    return;
  if (!newVNode && oldVNode) {
    const domNode = oldVNode._domNode;
    if (domNode?.parentNode) {
      domNode.parentNode.removeChild(domNode);
    }
    unmountVNode(oldVNode);
    return;
  }
  if (newVNode && !oldVNode) {
    const newDom = await createDom(newVNode);
    if (newDom instanceof Node) {
      parent.appendChild(newDom);
    }
    return;
  }
  const newIsPrimitive = typeof newVNode === "string" || typeof newVNode === "number";
  const oldIsPrimitive = typeof oldVNode === "string" || typeof oldVNode === "number";
  if (newIsPrimitive || oldIsPrimitive) {
    if (newIsPrimitive && oldIsPrimitive && String(newVNode) === String(oldVNode))
      return;
    const newDom = await createDom(newVNode);
    const oldDom = oldVNode?._domNode || parent.firstChild;
    if (oldDom?.parentNode && newDom instanceof Node) {
      oldDom.parentNode.replaceChild(newDom, oldDom);
    }
    if (oldVNode && typeof oldVNode === "object") {
      unmountVNode(oldVNode);
    }
    return;
  }
  const newVN = newVNode;
  const oldVN = oldVNode;
  const newType = newVN.type;
  const oldType = oldVN.type;
  if (newType !== oldType) {
    const newDom = await createDom(newVN);
    const oldDom = oldVN._domNode;
    if (oldDom?.parentNode && newDom instanceof Node) {
      oldDom.parentNode.replaceChild(newDom, oldDom);
    }
    unmountVNode(oldVN);
    return;
  }
  if (newType === TEXT) {
    const oldDom = oldVN._domNode;
    const newText = newVN.props.nodeValue ?? "";
    const oldText = oldVN.props.nodeValue ?? "";
    if (newText !== oldText && oldDom) {
      oldDom.nodeValue = newText;
    }
    newVN._domNode = oldDom;
    return;
  }
  if (newType === Fragment) {
    const newChildren2 = newVN.props?.children || [];
    const oldChildren2 = oldVN.props?.children || [];
    await patchChildren(parent, newChildren2, oldChildren2);
    newVN._domNode = oldVN._domNode;
    return;
  }
  if (typeof newType === "function") {
    const oldCtx = componentInstances.get(oldVN);
    if (oldCtx && newType === oldType) {
      componentInstances.delete(oldVN);
      componentInstances.set(newVN, oldCtx);
      oldCtx._vnode = newVN;
      beginComponent(newVN);
      const rendered = await oldCtx.Component(newVN.props);
      endComponent();
      newVN._rendered = rendered;
      const oldRendered = oldVN._rendered;
      const oldDom = oldVN._domNode;
      if (oldDom?.parentNode instanceof Node) {
        await patch(oldDom.parentNode, rendered, oldRendered);
        newVN._domNode = rendered?._domNode || oldDom;
      }
    } else {
      const rendered = await renderMaybeAsyncComponent(newType, newVN.props, newVN);
      newVN._rendered = rendered;
      const oldRendered = oldVN._rendered;
      const oldDom = oldVN._domNode;
      if (oldDom?.parentNode instanceof Node) {
        await patch(oldDom.parentNode, rendered, oldRendered);
        newVN._domNode = rendered?._domNode || oldDom;
      } else {
        const newDom = await createDom(rendered);
        if (parent && newDom instanceof Node) {
          parent.appendChild(newDom);
        }
        newVN._domNode = newDom;
      }
      if (oldCtx && newType !== oldType) {
        unmountVNode(oldVN);
      }
    }
    return;
  }
  const el = oldVN._domNode;
  if (!el || el.nodeType !== 1) {
    const newDom = await createDom(newVN);
    if (parent && newDom instanceof Node) {
      parent.appendChild(newDom);
    }
    unmountVNode(oldVN);
    return;
  }
  updateProps(el, newVN.props, oldVN.props);
  newVN._domNode = el;
  const newChildren = newVN.props?.children || [];
  const oldChildren = oldVN.props?.children || [];
  await patchChildren(el, newChildren, oldChildren);
}
async function patchChildren(parent, newChildren, oldChildren) {
  if (!(parent instanceof Node))
    return;
  const hasKeys = newChildren.some((c) => c?.key != null) || oldChildren.some((c) => c?.key != null);
  if (!hasKeys) {
    const maxLen = Math.max(newChildren.length, oldChildren.length);
    for (let i = 0; i < maxLen; i++) {
      const newChild = newChildren[i];
      const oldChild = oldChildren[i];
      if (i >= newChildren.length) {
        const dom = oldChild?._domNode;
        if (dom?.parentNode) {
          dom.parentNode.removeChild(dom);
        }
        unmountVNode(oldChild);
      } else if (i >= oldChildren.length) {
        const newDom = await createDom(newChild);
        if (newDom instanceof Node) {
          parent.appendChild(newDom);
        }
      } else {
        await patch(parent, newChild, oldChild);
      }
    }
    return;
  }
  const oldKeyMap = /* @__PURE__ */ new Map();
  oldChildren.forEach((child) => {
    if (child?.key != null) {
      oldKeyMap.set(child.key, child);
    }
  });
  const newKeySet = new Set(newChildren.filter((c) => c?.key != null).map((c) => c.key));
  oldChildren.forEach((oldChild) => {
    if (oldChild?.key != null && !newKeySet.has(oldChild.key)) {
      const dom = oldChild._domNode;
      if (dom?.parentNode) {
        dom.parentNode.removeChild(dom);
      }
      unmountVNode(oldChild);
    }
  });
  for (let i = 0; i < newChildren.length; i++) {
    const newChild = newChildren[i];
    const key = newChild?.key;
    if (key != null && oldKeyMap.has(key)) {
      const oldChild = oldKeyMap.get(key);
      const oldDom = oldChild._domNode;
      const childNodes = Array.from(parent.childNodes);
      const currentPos = childNodes.indexOf(oldDom);
      const desiredPos = i;
      if (currentPos !== desiredPos) {
        const refNode = childNodes[desiredPos] || null;
        if (oldDom && oldDom.parentNode === parent) {
          parent.insertBefore(oldDom, refNode);
        }
      }
      await patch(parent, newChild, oldChild);
    } else {
      const newDom = await createDom(newChild);
      if (newDom instanceof Node) {
        const childNodes = Array.from(parent.childNodes);
        const refNode = childNodes[i] || null;
        parent.insertBefore(newDom, refNode);
      }
    }
  }
}
function unmountVNode(vnode) {
  if (!vnode)
    return;
  if (vnode._cleanup && typeof vnode._cleanup === "function") {
    try {
      vnode._cleanup();
    } catch (e) {
      console.error("[Fynix] Text vnode cleanup error:", e);
    }
    vnode._cleanup = null;
  }
  if (typeof vnode.type === "function") {
    const ctx = componentInstances.get(vnode);
    if (ctx) {
      ctx._isMounted = false;
      ctx._subscriptionCleanups.forEach((u) => {
        try {
          u();
        } catch (e) {
          console.error("[Fynix] Cleanup error:", e);
        }
      });
      ctx.cleanups.forEach((c) => {
        try {
          c?.();
        } catch (e) {
          console.error("[Fynix] Effect cleanup error:", e);
        }
      });
      ctx._subscriptions.clear();
      ctx._accessedStates.clear();
      ctx._subscriptionCleanups = [];
      ctx.cleanups = [];
      ctx.hooks = [];
      ctx.effects = [];
      ctx.rerender = null;
      ctx._vnode = null;
      componentInstances.delete(vnode);
      pendingRerenders.delete(ctx);
    }
    unmountVNode(vnode._rendered);
    return;
  }
  if (vnode._domNode && vnode._domNode.nodeType === 1) {
    const anyNode = vnode._domNode;
    const eid = anyNode._rest_eid;
    if (eid) {
      delegatedEvents.forEach((map) => map.delete(eid));
    }
    if (anyNode._fynixCleanups) {
      anyNode._fynixCleanups.forEach((cleanup) => {
        try {
          cleanup();
        } catch (e) {
          console.error("[Fynix] Element cleanup error:", e);
        }
      });
      anyNode._fynixCleanups = null;
    }
  }
  if (vnode.props?.children) {
    vnode.props.children.forEach((c) => unmountVNode(c));
  }
  vnode._domNode = null;
  vnode._rendered = null;
}
function updateProps(el, newProps = {}, oldProps = {}) {
  if (!el || el.nodeType !== 1)
    return;
  for (const k of Object.keys(oldProps)) {
    if (k === "children")
      continue;
    if (!(k in newProps)) {
      if (k.startsWith("r-")) {
        const anyEl = el;
        const eid = anyEl._rest_eid;
        if (eid && delegatedEvents.has(k.slice(2).toLowerCase())) {
          delegatedEvents.get(k.slice(2).toLowerCase()).delete(eid);
        }
      } else if (BOOLEAN_ATTRS.has(k.toLowerCase())) {
        el.removeAttribute(k);
        el[k] = false;
      } else if (DOM_PROPERTIES.has(k)) {
        el[k] = "";
      } else {
        el.removeAttribute(k);
      }
    }
  }
  for (const [k, v] of Object.entries(newProps)) {
    if (k === "children")
      continue;
    if (oldProps[k] !== v) {
      setProperty(el, k, v);
    }
  }
}
function mount(AppComponent, root, props = {}) {
  if (typeof root === "string") {
    const element = document.querySelector(root);
    if (!element) {
      console.error("[Fynix] Mount error: Element not found for selector:", root);
      return;
    }
    root = element;
  }
  if (!(root instanceof Element)) {
    console.error("[Fynix] Mount error: Invalid root element", root);
    return;
  }
  let Component = AppComponent;
  let oldVNode = null;
  let currentProps = props;
  let appVNode = null;
  let isRendering = false;
  async function renderApp() {
    if (isRendering)
      return;
    isRendering = true;
    try {
      removeErrorOverlay();
      const win2 = window;
      const propsToUse = win2.__lastRouteProps || win2.__fynix__?.lastRouteProps || currentProps;
      if (!appVNode) {
        appVNode = { type: Component, props: propsToUse, key: null };
        if (root instanceof Element) {
          root.innerHTML = "";
          const dom = await createDom(appVNode);
          if (dom instanceof Node) {
            root.appendChild(dom);
          }
        } else {
          console.error("[Fynix] Mount error: root is not a DOM Element", root);
          return;
        }
        oldVNode = appVNode;
      } else {
        appVNode.props = propsToUse;
        if (root instanceof Node) {
          await patch(root, appVNode, oldVNode);
          oldVNode = appVNode;
        } else {
          console.error("[Fynix] Patch error: root is not a DOM Node", root);
          return;
        }
      }
    } catch (err) {
      console.error("[Fynix] Mount error:", err);
      showErrorOverlay(err);
    } finally {
      isRendering = false;
    }
  }
  rootRenderFn = renderApp;
  const win = window;
  win.__fynix__ = win.__fynix__ || {};
  win.__fynix__.rerender = renderApp;
  renderApp();
  if (import.meta.hot) {
    if (!win.__fynix__.hmr) {
      win.__fynix__.hmr = async ({ mod }) => {
        try {
          const UpdatedComponent = mod.App || mod.default;
          if (UpdatedComponent) {
            Component = UpdatedComponent;
            if (appVNode) {
              appVNode.type = UpdatedComponent;
            }
            win.__fynix__.rerender?.();
          }
        } catch (err) {
          console.error("[Fynix HMR] update error:", err);
          showErrorOverlay(err);
        }
      };
      import.meta.hot.accept();
    }
  }
}

// node_modules/fynixui/dist/hooks/nixFor.js
function For(props) {
  let items = [];
  if (props.each && typeof props.each === "object" && "_isNixState" in props.each) {
    items = props.each.value;
  } else if (Array.isArray(props.each)) {
    items = props.each;
  }
  let renderer;
  if (typeof props.children === "function") {
    renderer = props.children;
  } else if (Array.isArray(props.children)) {
    const firstChild = props.children[0];
    if (typeof firstChild === "function") {
      renderer = firstChild;
    }
  }
  if (!renderer) {
    if (items.length > 0) {
      console.warn("[Fynix] <For> expects a function as its child. Received:", typeof props.children);
    }
    return { type: Fragment, props: { children: [] }, key: null };
  }
  const mapped = items.map((item, index) => {
    try {
      return renderer(item, index);
    } catch (error) {
      console.error(`[Fynix] Error rendering item at index ${index}:`, error);
      return {
        type: "div",
        props: {
          children: ["Error rendering item"],
          style: "color: red;"
        },
        key: index
      };
    }
  });
  return { type: Fragment, props: { children: mapped }, key: null };
}
export {
  Button,
  For,
  Fragment,
  Fynix,
  Path,
  Suspense,
  TEXT,
  clearLinkProps,
  router_default as createFynix,
  createTextVNode,
  h,
  mount,
  nixAsync,
  nixAsyncCached,
  nixAsyncDebounce,
  nixAsyncQuery,
  nixCallback,
  nixComputed,
  nixDebounce,
  nixEffect,
  nixEffectAlways,
  nixEffectOnce,
  nixForm,
  nixFormAsync,
  nixInterval,
  nixLazy,
  nixLazyAsync,
  nixLazyFormAsync,
  nixLocalStorage,
  nixMemo,
  nixPrevious,
  nixRef,
  nixState,
  nixStore,
  patch,
  renderComponent,
  setLinkProps,
  useFiberRenderer,
  useHierarchicalStore
};
//# sourceMappingURL=fynixui.js.map
