import { mount } from "../runtime";
const MAX_CACHE_SIZE = 50;
const PROPS_NAMESPACE = "__fynixLinkProps__";
const MAX_LISTENERS = 100;
const ALLOWED_PROTOCOLS = ["http:", "https:", ""];
const RENDER_DEBOUNCE = 10;
let routerInstance = null;
let isRouterInitialized = false;
function isExternal(url) {
    return /^https?:\/\//.test(url);
}
function escapeHTML(str) {
    if (typeof str !== "string")
        return "";
    return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;")
        .replace(/`/g, "&#96;")
        .replace(/\//g, "&#x2F;")
        .replace(/=/g, "&#x3D;")
        .replace(/\(/g, "&#x28;")
        .replace(/\)/g, "&#x29;")
        .replace(/\{/g, "&#x7B;")
        .replace(/\}/g, "&#x7D;")
        .replace(/\[/g, "&#x5B;")
        .replace(/\]/g, "&#x5D;");
}
function sanitizeContent(content) {
    return content
        .replace(/<script[^>]*>.*?<\/script>/gis, "")
        .replace(/<iframe[^>]*>.*?<\/iframe>/gis, "")
        .replace(/<object[^>]*>.*?<\/object>/gis, "")
        .replace(/<embed[^>]*>/gi, "")
        .replace(/<link[^>]*>/gi, "")
        .replace(/on\w+\s*=/gi, "")
        .replace(/javascript:/gi, "")
        .replace(/vbscript:/gi, "")
        .replace(/data:/gi, "")
        .replace(/expression\s*\(/gi, "");
}
function sanitizeProps(props) {
    const sanitized = {};
    for (const [key, value] of Object.entries(props)) {
        if (typeof key !== "string" ||
            key.startsWith("__") ||
            key.includes("javascript") ||
            key.includes("on")) {
            continue;
        }
        if (typeof value === "string") {
            const cleanContent = sanitizeContent(value);
            sanitized[key] = escapeHTML(cleanContent);
        }
        else if (typeof value === "object" && value !== null) {
            if (Object.keys(value).length < 50) {
                sanitized[key] = sanitizeProps(value);
            }
        }
        else if (typeof value === "number" || typeof value === "boolean") {
            sanitized[key] = value;
        }
    }
    return sanitized;
}
function isValidURL(url) {
    try {
        const suspiciousPatterns = [
            /javascript:/i,
            /vbscript:/i,
            /data:/i,
            /mailto:/i,
            /tel:/i,
            /ftp:/i,
            /file:/i,
            /%2f%2f/i,
            /%5c%5c/i,
            /\\\\/,
            /@/,
        ];
        if (suspiciousPatterns.some((pattern) => pattern.test(url))) {
            console.warn("[Router] Security: Suspicious URL pattern blocked");
            return false;
        }
        const parsed = new URL(url, window.location.origin);
        if (parsed.origin !== window.location.origin) {
            console.warn("[Router] Security: Cross-origin navigation blocked");
            return false;
        }
        if (!ALLOWED_PROTOCOLS.includes(parsed.protocol)) {
            console.warn("[Router] Security: Dangerous protocol blocked:", parsed.protocol);
            return false;
        }
        const decodedPath = decodeURIComponent(parsed.pathname);
        if (decodedPath !== parsed.pathname && /[<>"'`]/.test(decodedPath)) {
            console.warn("[Router] Security: Encoded XSS attempt blocked");
            return false;
        }
        if (url.length > 2048) {
            console.warn("[Router] Security: Excessively long URL blocked");
            return false;
        }
        return true;
    }
    catch (e) {
        console.warn("[Router] Security: Invalid URL blocked");
        return false;
    }
}
function sanitizePath(path) {
    if (typeof path !== "string")
        return "/";
    try {
        path = decodeURIComponent(path);
    }
    catch (e) {
        console.warn("[Router] Invalid URL encoding in path");
        return "/";
    }
    path = path.replace(/\0/g, "");
    path = path.replace(/\\/g, "/");
    path = path.replace(/\/+/g, "/");
    path = path
        .split("/")
        .filter((part) => part !== ".." && part !== ".")
        .join("/");
    if (!path.startsWith("/")) {
        path = "/" + path;
    }
    if (path.length > 1 && path.endsWith("/")) {
        path = path.slice(0, -1);
    }
    return path || "/";
}
function tryGlobPaths() {
    try {
        let modules = import.meta.glob("/src/**/*.{fnx,tsx,jsx,ts,js}", {
            eager: true,
        });
        if (Object.keys(modules).length === 0) {
            modules = import.meta.glob(["./**/*.fnx", "./**/*.tsx", "./**/*.jsx", "./**/*.ts", "./**/*.js"], { eager: true });
        }
        if (Object.keys(modules).length === 0) {
            modules = import.meta.glob(["../**/*.fnx", "../**/*.tsx", "../**/*.jsx"], { eager: true });
        }
        return modules || {};
    }
    catch (error) {
        console.error("[Router] Failed to load modules:", error);
        return {};
    }
}
function filePathToRoute(filePath) {
    let route = filePath
        .replace(/^.*\/src/, "")
        .replace(/\.(ts|tsx|js|jsx|fnx)$/, "")
        .replace(/\/view$/, "")
        .replace(/\/$/, "");
    if (!route)
        route = "/";
    route = route.replace(/\[([^\]]+)\]/g, ":$1");
    return route;
}
function matchDynamicRoute(path, dynamicRoutes) {
    for (const route of dynamicRoutes) {
        const match = path.match(route.regex);
        if (match) {
            const params = {};
            route.params.forEach((param, i) => {
                const matchValue = match[i + 1];
                params[param] = escapeHTML(matchValue || "");
            });
            return { component: route.component, params };
        }
    }
    return null;
}
function deserializeProps(props) {
    if (!props || typeof props !== "object")
        return {};
    const deserialized = {};
    for (const [key, value] of Object.entries(props)) {
        if (typeof key !== "string" || key.startsWith("__")) {
            continue;
        }
        deserialized[key] = value;
    }
    return deserialized;
}
function normalizePath(path) {
    return sanitizePath(path);
}
function generateCacheKey() {
    if (typeof crypto !== "undefined" && crypto.randomUUID) {
        return crypto.randomUUID();
    }
    return `${Date.now()}-${Math.random().toString(36).slice(2)}-${Math.random()
        .toString(36)
        .slice(2)}`;
}
function addToCache(cache, key, value) {
    if (cache.size >= MAX_CACHE_SIZE) {
        const firstKey = cache.keys().next().value;
        if (typeof firstKey === "string") {
            const evicted = cache.get(firstKey);
            if (evicted && typeof evicted === "object") {
                Object.values(evicted).forEach((val) => {
                    if (val && typeof val === "object" && "cleanup" in val) {
                        try {
                            val.cleanup();
                        }
                        catch (e) {
                        }
                    }
                });
            }
            cache.delete(firstKey);
        }
    }
    cache.set(key, value);
}
const MANAGED_META = [
    { key: "description", name: "description" },
    { key: "keywords", name: "keywords" },
    { key: "twitterCard", name: "twitter:card" },
    { key: "ogTitle", property: "og:title" },
    { key: "ogDescription", property: "og:description" },
    { key: "ogImage", property: "og:image" },
];
function updateMetaTags(meta = {}) {
    if (!meta || typeof meta !== "object")
        return;
    if (meta.title && typeof meta.title === "string") {
        const sanitizedTitle = escapeHTML(meta.title).substring(0, 60);
        document.title = sanitizedTitle;
    }
    MANAGED_META.forEach((def) => {
        const value = meta[def.key];
        const selector = def.name
            ? `meta[name="${CSS.escape(def.name)}"]`
            : `meta[property="${CSS.escape(def.property || "")}"]`;
        let el = document.querySelector(selector);
        if (value == null) {
            if (el)
                el.remove();
            return;
        }
        if (typeof value !== "string")
            return;
        const cleanValue = sanitizeContent(value);
        const sanitizedValue = escapeHTML(cleanValue).substring(0, 300);
        if (/javascript:|vbscript:|data:|<|>/i.test(sanitizedValue)) {
            console.warn(`[Router] Security: Blocked suspicious meta content for ${def.key}`);
            return;
        }
        if (!el) {
            el = document.createElement("meta");
            if (def.name)
                el.setAttribute("name", def.name);
            if (def.property)
                el.setAttribute("property", def.property);
            document.head.appendChild(el);
        }
        el.setAttribute("content", sanitizedValue);
    });
}
class EnterpriseRouter {
    constructor() {
        this.routeCache = new Map();
        this.preloadQueue = new Set();
        this.routeMatchCache = new Map();
        this.routes = {};
    }
    setRoutes(routes) {
        if (!routes || typeof routes !== "object") {
            console.warn("[EnterpriseRouter] Invalid routes configuration");
            return;
        }
        this.routes = routes;
    }
    async preloadRoute(path) {
        if (this.routeCache.has(path))
            return;
        const route = this.routes[path];
        if (route?.component) {
            const loadRoute = async () => {
                try {
                    const component = await route.component();
                    this.routeCache.set(path, component);
                    route.prefetch?.forEach((prefetchPath) => {
                        this.preloadQueue.add(prefetchPath);
                    });
                    console.log(`[EnterpriseRouter] Preloaded route: ${path}`);
                }
                catch (error) {
                    console.warn(`[EnterpriseRouter] Failed to preload route ${path}:`, error);
                }
            };
            if ("requestIdleCallback" in window) {
                requestIdleCallback(loadRoute);
            }
            else {
                setTimeout(loadRoute, 0);
            }
        }
    }
    matchRoute(path) {
        const cached = this.routeMatchCache.get(path);
        if (cached !== undefined)
            return cached;
        const match = this.computeRouteMatch(path);
        if (this.routeMatchCache.size > 100) {
            const firstKey = this.routeMatchCache.keys().next().value;
            if (firstKey !== undefined) {
                this.routeMatchCache.delete(firstKey);
            }
        }
        this.routeMatchCache.set(path, match);
        return match;
    }
    computeRouteMatch(path) {
        const segments = path.split("/").filter(Boolean);
        for (const [routePath, routeConfig] of Object.entries(this.routes)) {
            const routeSegments = routePath.split("/").filter(Boolean);
            if (segments.length !== routeSegments.length)
                continue;
            const params = {};
            let isMatch = true;
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                const routeSegment = routeSegments[i];
                if (routeSegment && segment) {
                    if (routeSegment.startsWith(":")) {
                        params[routeSegment.slice(1)] = segment;
                    }
                    else if (segment !== routeSegment) {
                        isMatch = false;
                        break;
                    }
                }
                else {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                return {
                    component: routeConfig.component,
                    params,
                    meta: typeof routeConfig.meta === "function"
                        ? routeConfig.meta(params)
                        : routeConfig.meta,
                };
            }
        }
        return null;
    }
    async checkRouteGuard(route, path, params) {
        if (!route.guard)
            return true;
        if (route.guard.canActivate) {
            const canActivate = await route.guard.canActivate(path, params);
            return canActivate;
        }
        return true;
    }
    getPreloadedComponent(path) {
        return this.routeCache.get(path);
    }
    clearCache() {
        this.routeCache.clear();
        this.routeMatchCache.clear();
        this.preloadQueue.clear();
    }
}
class LayoutRouter {
    constructor() {
        this.layoutCache = new Map();
        this.keepAliveComponents = new Map();
    }
    renderNestedRoutes(routes, segments) {
        if (segments.length === 0)
            return null;
        const [currentSegment, ...remainingSegments] = segments;
        const currentRoute = routes.find((r) => r.path === currentSegment);
        if (!currentRoute)
            return null;
        let content;
        if (remainingSegments.length > 0 && currentRoute.children) {
            content = this.renderNestedRoutes(currentRoute.children, remainingSegments);
        }
        else {
            if (currentRoute.keepAlive && currentSegment) {
                content = this.renderKeepAlive(currentRoute.component, currentSegment);
            }
            else {
                content = this.renderComponent(currentRoute.component);
            }
        }
        if (currentRoute.layout) {
            const layoutKey = `${currentSegment}_layout`;
            let layoutComponent = this.layoutCache.get(layoutKey);
            if (!layoutComponent) {
                layoutComponent = this.renderComponent(currentRoute.layout);
                this.layoutCache.set(layoutKey, layoutComponent);
            }
            return this.renderComponent(currentRoute.layout, { children: content });
        }
        return content;
    }
    renderKeepAlive(component, key) {
        if (this.keepAliveComponents.has(key)) {
            return this.keepAliveComponents.get(key);
        }
        const rendered = this.renderComponent(component);
        this.keepAliveComponents.set(key, rendered);
        return rendered;
    }
    renderComponent(component, props = {}) {
        try {
            return component(props);
        }
        catch (error) {
            console.error("[LayoutRouter] Component render error:", error);
            return null;
        }
    }
    cleanup() {
        this.layoutCache.clear();
        this.keepAliveComponents.clear();
    }
}
const enterpriseRouter = new EnterpriseRouter();
const layoutRouter = new LayoutRouter();
function createFynix() {
    const isDevMode = import.meta.hot !== undefined;
    if (routerInstance && isRouterInitialized && !isDevMode) {
        console.warn("[Router] Router already initialized, returning existing instance");
        return routerInstance;
    }
    if (isDevMode && routerInstance) {
        console.log("[Router] HMR: Cleaning up old router instance");
        routerInstance.cleanup();
        routerInstance = null;
        isRouterInitialized = false;
    }
    let rootSelector = "#app-root";
    let currentPath = null;
    let isDestroyed = false;
    let listenerCount = 0;
    let renderTimeout = null;
    let lastNavigationTime = 0;
    const NAVIGATION_RATE_LIMIT = 100;
    const listeners = [];
    if (!window[PROPS_NAMESPACE]) {
        window[PROPS_NAMESPACE] = {};
    }
    if (isDevMode && window.__fynixPropsCache) {
        window.__fynixPropsCache.clear();
    }
    const propsCache = window.__fynixPropsCache || new Map();
    window.__fynixPropsCache = propsCache;
    const modules = tryGlobPaths();
    const routes = {};
    const dynamicRoutes = [];
    for (const [filePath, mod] of Object.entries(modules)) {
        const routePath = filePathToRoute(filePath);
        let component = undefined;
        if (mod && typeof mod === "object") {
            if ("default" in mod && mod.default) {
                component = mod.default;
            }
            else {
                const keys = Object.keys(mod);
                const firstKey = keys.length > 0 ? keys[0] : undefined;
                if (firstKey !== undefined &&
                    typeof firstKey === "string" &&
                    typeof mod[firstKey] !== "undefined") {
                    component = mod[firstKey];
                }
                else {
                    const values = Object.values(mod).filter(Boolean);
                    if (values.length > 0) {
                        component = values[0];
                    }
                }
            }
        }
        if (!component || typeof routePath !== "string")
            continue;
        const hasDynamic = /:[^/]+/.test(routePath);
        if (hasDynamic) {
            dynamicRoutes.push({
                pattern: routePath,
                regex: new RegExp("^" + routePath.replace(/:[^/]+/g, "([^/]+)") + "$"),
                component,
                params: [...routePath.matchAll(/:([^/]+)/g)]
                    .map((m) => m[1])
                    .filter((p) => typeof p === "string"),
            });
        }
        else {
            routes[routePath] = component;
        }
    }
    async function renderRouteImmediate() {
        if (isDestroyed)
            return;
        const path = normalizePath(window.location.pathname);
        let Page = routes[path];
        let params = {};
        let routeProps = {};
        const enterpriseMatch = enterpriseRouter.matchRoute(path);
        if (enterpriseMatch) {
            const preloadedComponent = enterpriseRouter.getPreloadedComponent(path);
            if (preloadedComponent) {
                Page = preloadedComponent;
            }
            else {
                Page = enterpriseMatch.component;
            }
            params = enterpriseMatch.params;
        }
        if (!Page) {
            const match = matchDynamicRoute(path, dynamicRoutes);
            if (match) {
                Page = match.component;
                params = match.params;
            }
        }
        const root = document.querySelector(rootSelector);
        if (!root) {
            console.error("[Router] Root element not found:", rootSelector);
            return;
        }
        if (!Page) {
            root.innerHTML = "";
            const container = document.createElement("div");
            container.style.cssText =
                "padding: 2rem; text-align: center; font-family: system-ui, sans-serif;";
            const heading = document.createElement("h2");
            heading.textContent = "404 Not Found";
            heading.style.cssText = "color: #dc2626; margin-bottom: 1rem;";
            const pathInfo = document.createElement("p");
            const safePath = escapeHTML(sanitizeContent(path));
            pathInfo.textContent = `Path: ${safePath}`;
            pathInfo.style.cssText = "color: #6b7280; margin-bottom: 2rem;";
            const backButton = document.createElement("button");
            backButton.textContent = "Go Back";
            backButton.style.cssText =
                "padding: 0.5rem 1rem; background: #3b82f6; color: white; border: none; border-radius: 0.25rem; cursor: pointer;";
            backButton.onclick = () => window.history.back();
            container.appendChild(heading);
            container.appendChild(pathInfo);
            container.appendChild(backButton);
            root.appendChild(container);
            updateMetaTags({ title: "404 - Page Not Found" });
            ["/", "/home", "/about"].forEach((commonPath) => {
                enterpriseRouter.preloadRoute(commonPath).catch(console.warn);
            });
            return;
        }
        const state = (window.history.state || {});
        let passedProps = {};
        if (state.__fynixCacheKey && propsCache.has(state.__fynixCacheKey)) {
            passedProps = propsCache.get(state.__fynixCacheKey);
        }
        else if (state.serializedProps) {
            passedProps = deserializeProps(state.serializedProps);
        }
        if (Page.props) {
            routeProps = typeof Page.props === "function" ? Page.props() : Page.props;
        }
        if (Page.meta) {
            const meta = typeof Page.meta === "function" ? Page.meta(params) : Page.meta;
            updateMetaTags(meta);
        }
        const unsafeProps = {
            ...routeProps,
            ...passedProps,
            params,
        };
        const safeProps = sanitizeProps(unsafeProps);
        window.__lastRouteProps = safeProps;
        try {
            mount(Page, rootSelector, safeProps);
        }
        catch (err) {
            console.error("[Router] Mount failed:", err);
            root.innerHTML = "";
            const errorDiv = document.createElement("pre");
            errorDiv.style.color = "red";
            errorDiv.textContent = "Mount Error occurred";
            root.appendChild(errorDiv);
        }
        currentPath = path;
    }
    function renderRoute() {
        if (isDestroyed)
            return;
        if (renderTimeout) {
            clearTimeout(renderTimeout);
        }
        renderTimeout = setTimeout(async () => {
            await renderRouteImmediate();
            renderTimeout = null;
        }, RENDER_DEBOUNCE);
    }
    function navigate(path, props = {}) {
        if (isDestroyed)
            return;
        const now = Date.now();
        if (now - lastNavigationTime < NAVIGATION_RATE_LIMIT) {
            console.warn("[Router] Security: Navigation rate limited");
            return;
        }
        lastNavigationTime = now;
        const normalizedPath = normalizePath(path);
        if (!isValidURL(window.location.origin + normalizedPath)) {
            console.error("[Router] Invalid navigation URL");
            return;
        }
        if (normalizedPath === currentPath)
            return;
        enterpriseRouter.preloadRoute(normalizedPath).catch(console.warn);
        const sanitizedProps = sanitizeProps(props);
        const cacheKey = generateCacheKey();
        addToCache(propsCache, cacheKey, sanitizedProps);
        try {
            window.history.pushState({ __fynixCacheKey: cacheKey }, "", normalizedPath);
            renderRoute();
        }
        catch (err) {
            console.error("[Router] Navigation failed:", err);
        }
    }
    function replace(path, props = {}) {
        if (isDestroyed)
            return;
        const now = Date.now();
        if (now - lastNavigationTime < NAVIGATION_RATE_LIMIT) {
            console.warn("[Router] Security: Replace rate limited");
            return;
        }
        lastNavigationTime = now;
        const normalizedPath = normalizePath(path);
        if (!isValidURL(window.location.origin + normalizedPath)) {
            console.error("[Router] Invalid replace URL");
            return;
        }
        const sanitizedProps = sanitizeProps(props);
        const cacheKey = generateCacheKey();
        addToCache(propsCache, cacheKey, sanitizedProps);
        try {
            window.history.replaceState({ __fynixCacheKey: cacheKey }, "", normalizedPath);
            renderRoute();
        }
        catch (err) {
            console.error("[Router] Replace failed:", err);
        }
    }
    function back() {
        if (isDestroyed)
            return;
        try {
            window.history.back();
        }
        catch (err) {
            console.error("[Router] Back navigation failed:", err);
        }
    }
    const clickHandler = (e) => {
        if (isDestroyed)
            return;
        const target = e.target;
        const link = target.closest("a[data-fynix-link]");
        if (!link)
            return;
        const href = link.getAttribute("href");
        if (!href) {
            console.warn("[Router] Missing href attribute");
            return;
        }
        if (isExternal(href)) {
            return;
        }
        const fullUrl = new URL(link.href, window.location.origin).href;
        if (!isValidURL(fullUrl)) {
            console.warn("[Router] Invalid link href");
            return;
        }
        e.preventDefault();
        const path = normalizePath(new URL(link.href, window.location.origin).pathname);
        if (path === currentPath)
            return;
        let props = {};
        const propsKey = link.getAttribute("data-props-key");
        if (propsKey &&
            typeof propsKey === "string" &&
            !propsKey.startsWith("__")) {
            if (window[PROPS_NAMESPACE]?.[propsKey]) {
                props = window[PROPS_NAMESPACE][propsKey];
            }
        }
        const serializableProps = {};
        for (const [k, v] of Object.entries(props)) {
            if (typeof k !== "string" || k.startsWith("__"))
                continue;
            serializableProps[k] =
                v && (v._isNixState || v._isRestState) ? v.value : v;
        }
        const cacheKey = generateCacheKey();
        addToCache(propsCache, cacheKey, serializableProps);
        try {
            window.history.pushState({ __fynixCacheKey: cacheKey, serializedProps: serializableProps }, "", path);
            renderRoute();
        }
        catch (err) {
            console.error("[Router] Link navigation failed:", err);
        }
    };
    if (listenerCount < MAX_LISTENERS && !isRouterInitialized) {
        document.addEventListener("click", clickHandler);
        listeners.push({
            element: document,
            event: "click",
            handler: clickHandler,
        });
        listenerCount++;
        window.addEventListener("popstate", renderRoute);
        listeners.push({
            element: window,
            event: "popstate",
            handler: renderRoute,
        });
        listenerCount++;
    }
    function mountRouter(selector = "#app-root") {
        if (isDestroyed) {
            console.error("[Router] Cannot mount destroyed router");
            return;
        }
        if (typeof selector !== "string" || selector.length === 0) {
            console.error("[Router] Invalid selector");
            return;
        }
        rootSelector = selector;
        renderRoute();
        isRouterInitialized = true;
    }
    function cleanup() {
        if (renderTimeout) {
            clearTimeout(renderTimeout);
            renderTimeout = null;
        }
        isDestroyed = true;
        enterpriseRouter.clearCache();
        layoutRouter.cleanup();
        listeners.forEach(({ element, event, handler }) => {
            try {
                element.removeEventListener(event, handler);
            }
            catch (e) {
                console.error("[Router] Cleanup error:", e);
            }
        });
        listeners.length = 0;
        listenerCount = 0;
        propsCache.forEach((props) => {
            if (props && typeof props === "object") {
                Object.values(props).forEach((val) => {
                    if (val && typeof val === "object" && "cleanup" in val) {
                        try {
                            val.cleanup();
                        }
                        catch (e) {
                        }
                    }
                });
            }
        });
        propsCache.clear();
        if (window[PROPS_NAMESPACE]) {
            const ns = window[PROPS_NAMESPACE];
            if (ns && typeof ns === "object") {
                Object.keys(ns).forEach((key) => {
                    delete ns[key];
                });
            }
            delete window[PROPS_NAMESPACE];
        }
        if (window.__lastRouteProps) {
            delete window.__lastRouteProps;
        }
        isRouterInitialized = false;
        routerInstance = null;
        console.log("[Router] Cleanup complete");
    }
    if (import.meta.hot) {
        import.meta.hot.accept(() => {
            console.log("[Router] HMR detected, re-rendering route...");
            renderRoute();
        });
        import.meta.hot.dispose(() => {
            console.log("[Router] HMR dispose, cleaning up...");
            cleanup();
            routerInstance = null;
            isRouterInitialized = false;
        });
    }
    const router = {
        mountRouter,
        navigate,
        replace,
        back,
        cleanup,
        routes,
        dynamicRoutes,
        preloadRoute: enterpriseRouter.preloadRoute.bind(enterpriseRouter),
        clearCache: () => {
            enterpriseRouter.clearCache();
            layoutRouter.cleanup();
        },
        enableNestedRouting: (nestedRoutes) => {
            router.nestedRoutes = nestedRoutes;
            console.log("[Router] Nested routing enabled with", nestedRoutes.length, "routes");
        },
    };
    routerInstance = router;
    return router;
}
export { createFynix };
export default createFynix;
export function setLinkProps(key, props) {
    if (typeof key !== "string" || key.startsWith("__")) {
        console.error("[Router] Invalid props key");
        return;
    }
    if (!props || typeof props !== "object") {
        console.error("[Router] Invalid props object");
        return;
    }
    if (!window[PROPS_NAMESPACE]) {
        window[PROPS_NAMESPACE] = {};
    }
    if (Object.keys(window[PROPS_NAMESPACE]).length >= MAX_CACHE_SIZE) {
        console.warn("[Router] Props storage limit reached");
        return;
    }
    window[PROPS_NAMESPACE][key] = props;
}
export function clearLinkProps(key) {
    if (typeof key !== "string")
        return;
    if (window[PROPS_NAMESPACE]?.[key]) {
        const props = window[PROPS_NAMESPACE][key];
        if (props && typeof props === "object") {
            Object.values(props).forEach((val) => {
                if (val && typeof val === "object" && "cleanup" in val) {
                    try {
                        val.cleanup();
                    }
                    catch (e) {
                    }
                }
            });
        }
        delete window[PROPS_NAMESPACE][key];
    }
}
