export function nixDebounce(fn, delay = 300, options = {}) {
    let timerId = null;
    let lastInvokeTime = 0;
    let lastArgs = null;
    let lastThis = null;
    const { leading = false, trailing = true, maxWait, signal } = options;
    if (signal) {
        signal.addEventListener("abort", () => {
            if (timerId) {
                clearTimeout(timerId);
                timerId = null;
            }
            lastArgs = null;
            lastThis = null;
        });
    }
    const invoke = () => {
        lastInvokeTime = Date.now();
        if (lastArgs) {
            fn.apply(lastThis, lastArgs);
            lastArgs = lastThis = null;
        }
    };
    const debounced = function (...args) {
        const now = Date.now();
        lastArgs = args;
        lastThis = this;
        const shouldInvokeLeading = leading && !timerId;
        const timeSinceLastInvoke = now - lastInvokeTime;
        const remainingTime = delay - timeSinceLastInvoke;
        if (maxWait !== undefined && timeSinceLastInvoke >= maxWait) {
            if (timerId)
                clearTimeout(timerId);
            timerId = null;
            invoke();
            return;
        }
        if (timerId)
            clearTimeout(timerId);
        if (shouldInvokeLeading) {
            invoke();
        }
        if (trailing) {
            timerId = setTimeout(invoke, remainingTime > 0 ? remainingTime : delay);
        }
    };
    debounced.cancel = () => {
        if (timerId)
            clearTimeout(timerId);
        timerId = null;
        lastArgs = null;
        lastThis = null;
    };
    return debounced;
}
