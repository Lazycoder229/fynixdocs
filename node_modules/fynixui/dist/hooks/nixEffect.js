import { activeContext } from "../context/context";
export function nixEffect(effect, deps = []) {
    const ctx = activeContext;
    if (!ctx)
        throw new Error("nixEffect() called outside component");
    if (typeof effect !== "function") {
        console.error("[nixEffect] First argument must be a function");
        return;
    }
    if (!Array.isArray(deps)) {
        console.error("[nixEffect] Second argument must be an array");
        deps = [];
    }
    const MAX_DEPS = 100;
    if (deps.length > MAX_DEPS) {
        console.warn(`[nixEffect] Dependency array too large (${deps.length}). Limited to ${MAX_DEPS}.`);
        deps = deps.slice(0, MAX_DEPS);
    }
    const idx = ctx.hookIndex++;
    const prev = ctx.hooks[idx];
    const hasChanged = !prev || !shallowArrayEqual(prev.deps, deps);
    if (hasChanged) {
        if (prev?.cleanup) {
            try {
                if (typeof prev.cleanup === "function") {
                    prev.cleanup();
                }
            }
            catch (err) {
                console.error("[nixEffect] Cleanup error:", err);
            }
        }
        let cleanup;
        try {
            cleanup = effect();
            if (cleanup !== undefined && typeof cleanup !== "function") {
                console.warn("[nixEffect] Effect should return undefined or a cleanup function");
                cleanup = undefined;
            }
        }
        catch (err) {
            console.error("[nixEffect] Effect error:", err);
            cleanup = undefined;
        }
        ctx.hooks[idx] = { deps, cleanup };
        if (cleanup && typeof cleanup === "function") {
            if (!ctx.cleanups)
                ctx.cleanups = [];
            ctx.cleanups.push(cleanup);
        }
    }
}
function shallowArrayEqual(arr1, arr2) {
    if (arr1.length !== arr2.length)
        return false;
    for (let i = 0; i < arr1.length; i++) {
        if (!Object.is(arr1[i], arr2[i])) {
            return false;
        }
    }
    return true;
}
export function nixEffectOnce(effect) {
    return nixEffect(effect, []);
}
export function nixEffectAlways(effect) {
    const ctx = activeContext;
    if (!ctx)
        throw new Error("nixEffectAlways() called outside component");
    if (typeof effect !== "function") {
        console.error("[nixEffectAlways] Argument must be a function");
        return;
    }
    return nixEffect(effect, [ctx.version]);
}
