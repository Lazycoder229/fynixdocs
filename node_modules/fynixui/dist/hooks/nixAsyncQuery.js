import { nixState } from "./nixState";
const asyncCache = new Map();
export function nixAsyncQuery(key, queryFn, options = {}) {
    const data = nixState(null);
    const error = nixState(null);
    const loading = nixState(false);
    const ttl = options.ttl ?? 0;
    let active = true;
    let callId = 0;
    const run = async () => {
        const id = ++callId;
        loading.value = true;
        error.value = null;
        const now = Date.now();
        const cached = asyncCache.get(key);
        if (cached?.data &&
            (!ttl ||
                (typeof cached.timestamp === "number" && now - cached.timestamp < ttl))) {
            data.value = cached.data;
            loading.value = false;
            return;
        }
        if (cached?.promise) {
            try {
                const result = await cached.promise;
                if (!active || id !== callId)
                    return;
                const safeResult = typeof result === "object" && result !== null
                    ? JSON.parse(JSON.stringify(result))
                    : result;
                data.value = safeResult;
            }
            catch (e) {
                if (!active || id !== callId)
                    return;
                error.value = e instanceof Error ? e : new Error(String(e));
            }
            finally {
                if (active && id === callId)
                    loading.value = false;
            }
            return;
        }
        const controller = new AbortController();
        const promise = (async () => {
            try {
                const result = await queryFn(controller.signal);
                asyncCache.set(key, {
                    data: result,
                    timestamp: Date.now(),
                });
                return result;
            }
            catch (e) {
                asyncCache.delete(key);
                throw e instanceof Error ? e : new Error(String(e));
            }
        })();
        asyncCache.set(key, { promise, controller });
        try {
            const result = await promise;
            if (!active || id !== callId)
                return;
            const safeResult = typeof result === "object" && result !== null
                ? JSON.parse(JSON.stringify(result))
                : result;
            data.value = safeResult;
        }
        catch (e) {
            if (!active || id !== callId)
                return;
            error.value = e instanceof Error ? e : new Error(String(e));
        }
        finally {
            if (active && id === callId)
                loading.value = false;
        }
    };
    const cancel = () => {
        active = false;
        const cached = asyncCache.get(key);
        if (cached?.controller) {
            cached.controller.abort();
        }
    };
    return { data, error, loading, run, cancel };
}
