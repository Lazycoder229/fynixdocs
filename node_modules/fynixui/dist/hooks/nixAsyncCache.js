import { nixState } from "./nixState";
const asyncCache = new Map();
const CACHE_CLEANUP_INTERVAL = 60000;
let cacheCleanupTimer = null;
const startCacheCleanup = () => {
    if (cacheCleanupTimer)
        return;
    cacheCleanupTimer = setInterval(() => {
        const now = Date.now();
        const entries = Array.from(asyncCache.entries());
        for (const [key, entry] of entries) {
            if (entry.timestamp && entry.ttl && now - entry.timestamp > entry.ttl) {
                asyncCache.delete(key);
            }
        }
        if (asyncCache.size === 0 && cacheCleanupTimer) {
            clearInterval(cacheCleanupTimer);
            cacheCleanupTimer = null;
        }
    }, CACHE_CLEANUP_INTERVAL);
};
export function nixAsyncCached(key, promiseFactory, options = {}) {
    if (!promiseFactory || typeof promiseFactory !== "function") {
        throw new Error("[nixAsyncCache] promiseFactory must be a function");
    }
    if (key == null) {
        throw new Error("[nixAsyncCache] Key cannot be null or undefined");
    }
    if (options.validateKey && !options.validateKey(key)) {
        throw new Error("[nixAsyncCache] Invalid cache key");
    }
    const { ttl = 300000, maxCacheSize = 100 } = options;
    if (asyncCache.size >= maxCacheSize) {
        const entries = Array.from(asyncCache.entries());
        const entriesToRemove = Math.max(1, Math.floor(maxCacheSize * 0.1));
        for (let i = 0; i < entriesToRemove; i++) {
            const entry = entries[i];
            if (entry) {
                asyncCache.delete(entry[0]);
            }
        }
    }
    const data = nixState(null);
    const error = nixState(null);
    const loading = nixState(false);
    let active = true;
    let abortController = null;
    startCacheCleanup();
    const run = async () => {
        if (!active)
            return;
        if (abortController) {
            abortController.abort();
        }
        abortController = new AbortController();
        loading.value = true;
        error.value = null;
        try {
            if (asyncCache.has(key)) {
                const cached = asyncCache.get(key);
                const now = Date.now();
                if (cached.timestamp && now - cached.timestamp > ttl) {
                    asyncCache.delete(key);
                }
                else if (cached.data !== undefined) {
                    data.value = cached.data;
                    loading.value = false;
                    return;
                }
                if (cached.promise) {
                    try {
                        const result = await cached.promise;
                        if (!active || abortController?.signal.aborted)
                            return;
                        data.value = result;
                        loading.value = false;
                        return;
                    }
                    catch (e) {
                        if (!active || abortController?.signal.aborted)
                            return;
                        error.value = e;
                        loading.value = false;
                        return;
                    }
                }
            }
            const promise = Promise.resolve().then(() => {
                if (abortController?.signal.aborted) {
                    throw new Error("Request was aborted");
                }
                return promiseFactory();
            });
            asyncCache.set(key, {
                promise,
                timestamp: Date.now(),
                ttl,
            });
            const result = await promise;
            if (!active || abortController?.signal.aborted)
                return;
            asyncCache.set(key, {
                data: result,
                timestamp: Date.now(),
                ttl,
            });
            data.value = result;
        }
        catch (e) {
            if (asyncCache.has(key)) {
                const cached = asyncCache.get(key);
                if (cached.promise && !cached.data) {
                    asyncCache.delete(key);
                }
            }
            if (!active || abortController?.signal.aborted)
                return;
            error.value = e;
        }
        finally {
            if (active && !abortController?.signal.aborted) {
                loading.value = false;
            }
        }
    };
    const cancel = () => {
        active = false;
        if (abortController) {
            abortController.abort();
            abortController = null;
        }
    };
    const clearCache = () => {
        asyncCache.delete(key);
    };
    return { data, error, loading, run, cancel, clearCache };
}
