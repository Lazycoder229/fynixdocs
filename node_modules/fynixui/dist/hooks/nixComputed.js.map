{
  "version": 3,
  "sources": ["../../hooks/nixComputed.ts"],
  "sourcesContent": ["/* MIT License\r\n\r\n* Copyright (c) 2026 Resty Gonzales\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n* SOFTWARE.\r\n */\r\n/* ----------------------\r\n    nixComputed - Computed/Derived State\r\n    Memory Leaks & Security Issues Resolved\r\n---------------------- */\r\nimport { activeContext, setActiveContext } from \"../context/context\";\r\n\r\n/**\r\n * @template T\r\n * @typedef {Object} ComputedState\r\n * @property {T} value - Get the computed value (read-only)\r\n * @property {(fn: (value: T) => void) => (() => void)} subscribe - Subscribe to computed value changes\r\n * @property {() => void} cleanup - Cleanup all subscriptions and dependencies\r\n * @property {() => number} getSubscriberCount - Get number of active subscribers (debugging)\r\n * @property {() => number} getDependencyCount - Get number of tracked dependencies (debugging)\r\n * @property {() => boolean} isDestroyed - Check if computed state has been destroyed\r\n * @property {boolean} _isNixState - Internal flag (computed states behave like states)\r\n * @property {boolean} _isComputed - Internal flag to identify computed states\r\n */\r\n\r\n/**\r\n * Create a derived/computed state from other states.\r\n * Automatically tracks dependencies and updates when any dependency changes.\r\n *\r\n * @template T\r\n * @param {() => T} computeFn - Function that computes the derived value\r\n * @returns {ComputedState<T>} A reactive state object with the computed value\r\n *\r\n * @example\r\n * const count = nixState(5);\r\n * const doubled = nixComputed(() => count.value * 2);\r\n * console.log(doubled.value); // 10\r\n * count.value = 10;\r\n * console.log(doubled.value); // 20\r\n *\r\n * @example\r\n * // Multiple dependencies\r\n * const a = nixState(5);\r\n * const b = nixState(10);\r\n * const sum = nixComputed(() => a.value + b.value);\r\n * console.log(sum.value); // 15\r\n *\r\n * @example\r\n * // Conditional dependencies\r\n * const flag = nixState(true);\r\n * const x = nixState(1);\r\n * const y = nixState(2);\r\n * const result = nixComputed(() => flag.value ? x.value : y.value);\r\n *\r\n * @example\r\n * // With cleanup\r\n * const MyComponent = () => {\r\n *   const count = nixState(0);\r\n *   const doubled = nixComputed(() => count.value * 2);\r\n *\r\n *   nixEffect(() => {\r\n *     return () => {\r\n *       doubled.cleanup();\r\n *       count.cleanup();\r\n *     };\r\n *   }, []);\r\n * };\r\n *\r\n * @throws {Error} If called outside a component context\r\n * @throws {TypeError} If computeFn is not a function\r\n */\r\nexport function nixComputed<T>(computeFn: () => T): {\r\n  value: T;\r\n  subscribe: (fn: (value: T) => void) => () => void;\r\n  cleanup: () => void;\r\n  getSubscriberCount: () => number;\r\n  getDependencyCount: () => number;\r\n  isDestroyed: () => boolean;\r\n  getDependencyInfo: () => Array<{\r\n    state: any;\r\n    hasCleanup: boolean;\r\n    isComputed: boolean;\r\n  }>;\r\n  _isNixState: true;\r\n  _isComputed: true;\r\n} {\r\n  const ctx = activeContext as\r\n    | (typeof activeContext & {\r\n        hookIndex: number;\r\n        hooks: Array<any>;\r\n        stateCleanups?: Array<() => void>;\r\n      })\r\n    | undefined;\r\n  if (!ctx) throw new Error(\"nixComputed() called outside component\");\r\n\r\n  if (typeof computeFn !== \"function\") {\r\n    throw new TypeError(\"[nixComputed] First argument must be a function\");\r\n  }\r\n\r\n  const idx = ctx.hookIndex++;\r\n  if (!ctx.hooks[idx]) {\r\n    const subscribers: Set<(value: T) => void> = new Set();\r\n    const dependencies: Set<any> = new Set();\r\n    const unsubscribers: Map<any, () => void> = new Map();\r\n    let cachedValue: T;\r\n    let isStale = true;\r\n    let isDestroyed = false;\r\n    let isComputing = false;\r\n\r\n    function compute(): T {\r\n      if (isDestroyed) return cachedValue;\r\n      if (isComputing) {\r\n        console.error(\"[nixComputed] Circular dependency detected\");\r\n        return cachedValue;\r\n      }\r\n      isComputing = true;\r\n      // Provide all required properties for ComponentContext type\r\n      // Use type assertion for safety and future-proofing\r\n      const trackingContext = {\r\n        _accessedStates: new Set(),\r\n        hookIndex: 0,\r\n        hooks: [],\r\n        _subscriptions: new Set(),\r\n        _subscriptionCleanups: [],\r\n        effects: [],\r\n        cleanups: [],\r\n        _vnode: null,\r\n        version: 0,\r\n        props: {},\r\n        stateCleanups: [],\r\n        parent: null,\r\n        context: {},\r\n        rerender: () => {},\r\n        Component: null,\r\n        _isMounted: false,\r\n        _isRerendering: false,\r\n      } as any; // Use 'as any' to satisfy ComponentContext type\r\n      const prevContext = activeContext;\r\n      try {\r\n        setActiveContext(trackingContext);\r\n        cachedValue = computeFn();\r\n        const oldDeps = Array.from(dependencies);\r\n        oldDeps.forEach((dep) => {\r\n          if (!trackingContext._accessedStates.has(dep)) {\r\n            if (unsubscribers.has(dep)) {\r\n              try {\r\n                unsubscribers.get(dep)!();\r\n              } catch (e) {\r\n                console.error(\r\n                  \"[nixComputed] Error unsubscribing from old dependency:\",\r\n                  e\r\n                );\r\n              }\r\n              unsubscribers.delete(dep);\r\n            }\r\n            dependencies.delete(dep);\r\n          }\r\n        });\r\n        trackingContext._accessedStates.forEach((state: any) => {\r\n          if (!dependencies.has(state)) {\r\n            const unsub = state.subscribe(() => {\r\n              if (isDestroyed) return;\r\n\r\n              isStale = true;\r\n              // Get fresh value when dependency changes\r\n              const newValue = s.value;\r\n              const subsArray = Array.from(subscribers);\r\n              subsArray.forEach((fn) => {\r\n                try {\r\n                  fn(newValue);\r\n                } catch (e) {\r\n                  console.error(\"[nixComputed] Subscriber error:\", e);\r\n                  subscribers.delete(fn);\r\n                }\r\n              });\r\n            });\r\n            unsubscribers.set(state, unsub);\r\n            dependencies.add(state);\r\n          }\r\n        });\r\n        isStale = false;\r\n      } catch (err) {\r\n        console.error(\"[nixComputed] Compute error:\", err);\r\n        isStale = false;\r\n      } finally {\r\n        setActiveContext(prevContext);\r\n        isComputing = false;\r\n      }\r\n      return cachedValue;\r\n    }\r\n\r\n    // All cleanup functionality is now part of the s object below\r\n\r\n    const s = {\r\n      get value(): T {\r\n        if (isDestroyed) {\r\n          console.warn(\"[nixComputed] Accessing destroyed computed state\");\r\n          return cachedValue;\r\n        }\r\n        if (isStale) {\r\n          compute();\r\n        }\r\n        if (activeContext && (activeContext as any)._accessedStates) {\r\n          (activeContext as any)._accessedStates.add(s);\r\n        }\r\n        return cachedValue;\r\n      },\r\n      subscribe(fn: (value: T) => void): () => void {\r\n        if (typeof fn !== \"function\") {\r\n          console.error(\"[nixComputed] subscribe() requires a function\");\r\n          return () => {};\r\n        }\r\n        if (isDestroyed) {\r\n          console.warn(\r\n            \"[nixComputed] Cannot subscribe to destroyed computed state\"\r\n          );\r\n          return () => {};\r\n        }\r\n        const MAX_SUBSCRIBERS = 1000;\r\n        if (subscribers.size >= MAX_SUBSCRIBERS) {\r\n          console.error(\"[nixComputed] Maximum subscriber limit reached\");\r\n          return () => {};\r\n        }\r\n        subscribers.add(fn);\r\n        return () => {\r\n          subscribers.delete(fn);\r\n        };\r\n      },\r\n      cleanup(): void {\r\n        if (isDestroyed) return;\r\n        isDestroyed = true;\r\n        unsubscribers.forEach((unsub) => {\r\n          try {\r\n            unsub();\r\n          } catch (e) {\r\n            console.error(\"[nixComputed] Cleanup error:\", e);\r\n          }\r\n        });\r\n        unsubscribers.clear();\r\n        dependencies.clear();\r\n        subscribers.clear();\r\n        cachedValue = null as any as T;\r\n        console.log(\"[nixComputed] Computed state cleaned up\");\r\n      },\r\n      getSubscriberCount(): number {\r\n        return subscribers.size;\r\n      },\r\n      getDependencyCount(): number {\r\n        return dependencies.size;\r\n      },\r\n      isDestroyed(): boolean {\r\n        return isDestroyed;\r\n      },\r\n      getDependencyInfo(): Array<{\r\n        state: any;\r\n        hasCleanup: boolean;\r\n        isComputed: boolean;\r\n      }> {\r\n        return Array.from(dependencies).map((state) => ({\r\n          state,\r\n          hasCleanup: unsubscribers.has(state),\r\n          isComputed: !!state._isComputed,\r\n        }));\r\n      },\r\n      _isNixState: true as const,\r\n      _isComputed: true as const,\r\n    };\r\n\r\n    compute();\r\n    ctx.hooks[idx] = s;\r\n    if (ctx.stateCleanups) {\r\n      ctx.stateCleanups.push(() => s.cleanup());\r\n    }\r\n  }\r\n  return ctx.hooks[idx] as ReturnType<typeof nixComputed<T>>;\r\n}\r\n"],
  "mappings": "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",
  "names": ["compute"]
}
