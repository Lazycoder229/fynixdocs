import { nixState } from "./nixState";
export function nixAsyncDebounce(promiseFactory, options = {}) {
    const data = nixState(null);
    const error = nixState(null);
    const loading = nixState(false);
    const { delay = 300, leading = false, trailing = true, maxWait, cache = true, signal, } = options;
    let lastResult = null;
    let lastError = null;
    let timerId = null;
    let lastInvokeTime = 0;
    let pendingPromise = null;
    const invoke = async () => {
        if (cache && lastResult !== null) {
            data.value = lastResult;
            error.value = lastError;
            loading.value = false;
            return lastResult;
        }
        loading.value = true;
        error.value = null;
        const abortController = new AbortController();
        if (signal) {
            signal.addEventListener("abort", () => {
                abortController.abort();
                cancel();
            });
        }
        pendingPromise = promiseFactory();
        try {
            const result = await pendingPromise;
            lastResult = result;
            data.value = result;
            return result;
        }
        catch (e) {
            if (e.name !== "AbortError") {
                lastError = e;
                error.value = e;
            }
            throw e;
        }
        finally {
            loading.value = false;
            pendingPromise = null;
            lastInvokeTime = Date.now();
        }
    };
    const run = () => {
        const now = Date.now();
        const timeSinceLastInvoke = now - lastInvokeTime;
        const remainingTime = delay - timeSinceLastInvoke;
        const shouldInvokeLeading = leading && !timerId;
        if (maxWait !== undefined && timeSinceLastInvoke >= maxWait) {
            if (timerId)
                clearTimeout(timerId);
            timerId = null;
            return invoke();
        }
        if (timerId)
            clearTimeout(timerId);
        if (shouldInvokeLeading)
            return invoke();
        if (trailing) {
            timerId = setTimeout(() => {
                timerId = null;
                invoke();
            }, remainingTime > 0 ? remainingTime : delay);
        }
    };
    const cancel = () => {
        if (timerId)
            clearTimeout(timerId);
        timerId = null;
        pendingPromise = null;
    };
    return { data, error, loading, run, cancel };
}
