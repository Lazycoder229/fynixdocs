import { activeContext, setActiveContext } from "../context/context";
export function nixComputed(computeFn) {
    const ctx = activeContext;
    if (!ctx)
        throw new Error("nixComputed() called outside component");
    if (typeof computeFn !== "function") {
        throw new TypeError("[nixComputed] First argument must be a function");
    }
    const idx = ctx.hookIndex++;
    if (!ctx.hooks[idx]) {
        const subscribers = new Set();
        const dependencies = new Set();
        const unsubscribers = new Map();
        let cachedValue;
        let isStale = true;
        let isDestroyed = false;
        let isComputing = false;
        function compute() {
            if (isDestroyed)
                return cachedValue;
            if (isComputing) {
                console.error("[nixComputed] Circular dependency detected");
                return cachedValue;
            }
            isComputing = true;
            const trackingContext = {
                _accessedStates: new Set(),
                hookIndex: 0,
                hooks: [],
                _subscriptions: new Set(),
                _subscriptionCleanups: [],
                effects: [],
                cleanups: [],
                _vnode: null,
                version: 0,
                props: {},
                stateCleanups: [],
                parent: null,
                context: {},
                rerender: () => { },
                Component: null,
                _isMounted: false,
                _isRerendering: false,
            };
            const prevContext = activeContext;
            try {
                setActiveContext(trackingContext);
                cachedValue = computeFn();
                const oldDeps = Array.from(dependencies);
                oldDeps.forEach((dep) => {
                    if (!trackingContext._accessedStates.has(dep)) {
                        if (unsubscribers.has(dep)) {
                            try {
                                unsubscribers.get(dep)();
                            }
                            catch (e) {
                                console.error("[nixComputed] Error unsubscribing from old dependency:", e);
                            }
                            unsubscribers.delete(dep);
                        }
                        dependencies.delete(dep);
                    }
                });
                trackingContext._accessedStates.forEach((state) => {
                    if (!dependencies.has(state)) {
                        const unsub = state.subscribe(() => {
                            if (isDestroyed)
                                return;
                            isStale = true;
                            const newValue = s.value;
                            const subsArray = Array.from(subscribers);
                            subsArray.forEach((fn) => {
                                try {
                                    fn(newValue);
                                }
                                catch (e) {
                                    console.error("[nixComputed] Subscriber error:", e);
                                    subscribers.delete(fn);
                                }
                            });
                        });
                        unsubscribers.set(state, unsub);
                        dependencies.add(state);
                    }
                });
                isStale = false;
            }
            catch (err) {
                console.error("[nixComputed] Compute error:", err);
                isStale = false;
            }
            finally {
                setActiveContext(prevContext);
                isComputing = false;
            }
            return cachedValue;
        }
        const s = {
            get value() {
                if (isDestroyed) {
                    console.warn("[nixComputed] Accessing destroyed computed state");
                    return cachedValue;
                }
                if (isStale) {
                    compute();
                }
                if (activeContext && activeContext._accessedStates) {
                    activeContext._accessedStates.add(s);
                }
                return cachedValue;
            },
            subscribe(fn) {
                if (typeof fn !== "function") {
                    console.error("[nixComputed] subscribe() requires a function");
                    return () => { };
                }
                if (isDestroyed) {
                    console.warn("[nixComputed] Cannot subscribe to destroyed computed state");
                    return () => { };
                }
                const MAX_SUBSCRIBERS = 1000;
                if (subscribers.size >= MAX_SUBSCRIBERS) {
                    console.error("[nixComputed] Maximum subscriber limit reached");
                    return () => { };
                }
                subscribers.add(fn);
                return () => {
                    subscribers.delete(fn);
                };
            },
            cleanup() {
                if (isDestroyed)
                    return;
                isDestroyed = true;
                unsubscribers.forEach((unsub) => {
                    try {
                        unsub();
                    }
                    catch (e) {
                        console.error("[nixComputed] Cleanup error:", e);
                    }
                });
                unsubscribers.clear();
                dependencies.clear();
                subscribers.clear();
                cachedValue = null;
                console.log("[nixComputed] Computed state cleaned up");
            },
            getSubscriberCount() {
                return subscribers.size;
            },
            getDependencyCount() {
                return dependencies.size;
            },
            isDestroyed() {
                return isDestroyed;
            },
            getDependencyInfo() {
                return Array.from(dependencies).map((state) => ({
                    state,
                    hasCleanup: unsubscribers.has(state),
                    isComputed: !!state._isComputed,
                }));
            },
            _isNixState: true,
            _isComputed: true,
        };
        compute();
        ctx.hooks[idx] = s;
        if (ctx.stateCleanups) {
            ctx.stateCleanups.push(() => s.cleanup());
        }
    }
    return ctx.hooks[idx];
}
