import { activeContext } from "../context/context";
export function nixStore(path, initial) {
    if (!path || typeof path !== "string") {
        throw new Error("[nixStore] Path must be a non-empty string");
    }
    const dangerousKeys = ["__proto__", "constructor", "prototype"];
    if (dangerousKeys.some((key) => path.includes(key))) {
        throw new Error("[nixStore] Path contains dangerous keywords");
    }
    if (path.length > 200) {
        throw new Error("[nixStore] Path too long (max 200 characters)");
    }
    const ctx = activeContext;
    if (!ctx)
        throw new Error("nixStore() called outside component");
    const idx = ctx.hookIndex++;
    if (!ctx.hooks[idx]) {
        let value = initial;
        const subscribers = new Set();
        let isDestroyed = false;
        let maxSubscribers = 100;
        const s = {
            get value() {
                if (isDestroyed) {
                    console.warn("[nixStore] Accessing destroyed store:", path);
                    return value;
                }
                try {
                    if (activeContext?._accessedStates) {
                        activeContext._accessedStates.add(s);
                    }
                }
                catch (err) {
                    console.error("[nixStore] Error tracking accessed state:", err);
                }
                return value;
            },
            set value(v) {
                if (isDestroyed) {
                    console.warn("[nixStore] Attempting to set value on destroyed store:", path);
                    return;
                }
                if (v && typeof v === "object") {
                    const safeValue = Object.create(null);
                    for (const key in v) {
                        if (Object.prototype.hasOwnProperty.call(v, key) &&
                            !dangerousKeys.includes(key)) {
                            safeValue[key] = v[key];
                        }
                    }
                    value = safeValue;
                }
                else {
                    value = v;
                }
                const subscriberArray = Array.from(subscribers);
                subscriberArray.forEach((fn) => {
                    try {
                        fn();
                    }
                    catch (err) {
                        console.error("[nixStore] Subscriber error:", err);
                        subscribers.delete(fn);
                    }
                });
            },
            subscribe(fn) {
                if (isDestroyed) {
                    console.warn("[nixStore] Attempting to subscribe to destroyed store:", path);
                    return () => { };
                }
                if (typeof fn !== "function") {
                    console.error("[nixStore] Subscriber must be a function");
                    return () => { };
                }
                if (subscribers.size >= maxSubscribers) {
                    console.warn(`[nixStore] Maximum subscribers (${maxSubscribers}) reached for store:`, path);
                    return () => { };
                }
                subscribers.add(fn);
                return () => {
                    subscribers.delete(fn);
                };
            },
            cleanup() {
                if (isDestroyed)
                    return;
                isDestroyed = true;
                subscribers.clear();
                console.debug(`[nixStore] Cleaned up store: ${path}`);
            },
            getSubscriberCount: () => subscribers.size,
            isDestroyed: () => isDestroyed,
            path,
            _isNixState: true,
        };
        if (!ctx.cleanups)
            ctx.cleanups = [];
        ctx.cleanups.push(() => s.cleanup());
        ctx.hooks[idx] = s;
    }
    return ctx.hooks[idx];
}
