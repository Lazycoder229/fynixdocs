import { nixState } from "./nixState";
export function nixAsync(promiseFactory, options = {}) {
    const { timeout = 30000, retries = 0, autoRun = false } = options;
    if (typeof promiseFactory !== "function") {
        throw new TypeError("[nixAsync] promiseFactory must be a function");
    }
    const data = nixState(null);
    const error = nixState(null);
    const loading = nixState(false);
    let active = true;
    let controller = null;
    let callId = 0;
    let timeoutId = null;
    let retryCount = 0;
    const cleanup = () => {
        active = false;
        if (controller) {
            controller.abort();
            controller = null;
        }
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        callId = 0;
        retryCount = 0;
    };
    const run = async () => {
        if (!active) {
            console.warn("[nixAsync] Attempted to run on destroyed async hook");
            return;
        }
        if (controller) {
            controller.abort();
        }
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        controller = new AbortController();
        const signal = controller.signal;
        const currentCallId = ++callId;
        retryCount = 0;
        loading.value = true;
        error.value = null;
        if (timeout > 0) {
            timeoutId = setTimeout(() => {
                if (controller && currentCallId === callId) {
                    controller.abort();
                    if (active && currentCallId === callId) {
                        error.value = new Error(`Request timeout after ${timeout}ms`);
                        loading.value = false;
                    }
                }
            }, timeout);
        }
        try {
            const result = await promiseFactory(signal);
            if (!active || currentCallId !== callId || signal.aborted) {
                return;
            }
            data.value = result;
            retryCount = 0;
        }
        catch (e) {
            if (!active || currentCallId !== callId) {
                return;
            }
            if (signal.aborted) {
                return;
            }
            const errorInstance = e instanceof Error ? e : new Error(String(e));
            if (retryCount < retries && active && currentCallId === callId) {
                retryCount++;
                console.warn(`[nixAsync] Retrying (${retryCount}/${retries}):`, errorInstance.message);
                const retryDelay = Math.min(1000 * Math.pow(2, retryCount - 1), 10000);
                setTimeout(() => {
                    if (active && currentCallId === callId) {
                        run();
                    }
                }, retryDelay);
                return;
            }
            error.value = errorInstance;
        }
        finally {
            if (timeoutId) {
                clearTimeout(timeoutId);
                timeoutId = null;
            }
            if (active && currentCallId === callId && !signal.aborted) {
                loading.value = false;
            }
        }
    };
    const cancel = () => {
        if (controller) {
            controller.abort();
        }
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        loading.value = false;
        retryCount = 0;
    };
    const getCallId = () => callId;
    if (autoRun) {
        setTimeout(() => {
            if (active)
                run();
        }, 0);
    }
    return { data, error, loading, run, cancel, cleanup, getCallId };
}
